<html>
      <head>
        <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1,user-scalable=no" />
        <meta charset="utf-8">
        <meta name="referrer" content="never">
        <title>P5022 旅行 | Kite-chaser</title>
        <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
        <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
        <link rel="stylesheet" href="https://Kite-chaser.github.io/styles/main.css">
          <script src="https://Kite-chaser.github.io/media/scripts/mdui.min.js"></script>
        <link rel="stylesheet" href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css">
        <link href="https://fonts.googleapis.com/css?family=Dancing+Script|Ma+Shan+Zheng&display=swap" rel="stylesheet">
        <script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
        <script src="https://Kite-chaser.github.io/media/scripts/script.js"></script>
        <script >hljs.initHighlightingOnLoad();</script>
        

    </head>
    <body class="mdui-theme-primary-purple mdui-theme-accent-purple">
        <header class="index-img mdui-m-b-3"  style="background-image: url(https://Kite-chaser.github.io/post-images/p5022-lu-xing.jpg);" >
                          <button class="mdui-btn  mdui-btn-icon mdui-btn-dense mdui-color-theme-500 mdui-ripple yinying mdui-m-t-1 mdui-m-l-1" mdui-menu="{target: '#demo-attr-cascade'}"><i class="mdui-icon material-icons">&#xe5d2;</i></button>
                <ul class="mdui-menu" id="demo-attr-cascade">
                
                        <li class="mdui-menu-item">
                          <a href="/" class="mdui-ripple">首页</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="/archives" class="mdui-ripple">归档</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="/tags" class="mdui-ripple">标签</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="https://Kite-chaser.github.io/post/guan-yu/" class="mdui-ripple">关于</a>
                        </li>
                
                        <li class="mdui-menu-item">
                          <a href="https://Kite-chaser.github.io/post/you-lian/" class="mdui-ripple">友链</a>
                        </li>
                
                      </ul>

        </header>
        <div class="mdui-container post">
                <div class="mdui-row">
                        <div class="mdui-col-md-8 mdui-col-offset-md-2 ">
                         <article class="mdui-shadow-10 mdui-p-a-2 post-list">
                           <div class="mdui-typo-display-1 mdui-m-b-3">P5022 旅行</div>
                           <a  class="index-list-biaoqian ">2019-11-11</a>
                           <div class="mdui-typo mdui-m-t-3 post-neirong"><p>口胡系列……</p>
<!--more-->
<h3 id="题目描述">题目描述</h3>
<p>小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。</p>
<p>小Y了解到， X国的 <em>n</em> 个城市之间有 <em>m</em> 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。</p>
<p>小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。</p>
<p>为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 <em>n</em> 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？ 对于两个长度均为 <em>n</em> 的序列 <em>A</em> 和 <em>B</em>，当且仅当存在一个正整数 <em>x</em>，满足以下条件时， 我们说序列 <em>A</em> 的字典序小于 <em>B</em>。</p>
<ul>
<li>对于任意正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1&lt;i&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，序列 <em>A</em> 的第 <em>i</em> 个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和序列 <em>B</em> 的第 <em>i</em> 个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相同。</li>
<li>序列 <em>A</em> 的第 <em>x</em> 个元素的值小于序列 <em>B</em> 的第 <em>x</em> 个元素的值。</li>
</ul>
<blockquote>
<p>[戳]（ https://www.luogu.org/problem/P5022 ）</p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>题意看似复杂，其实很显然。</p>
<p>首先让我们面向数据编程。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/a6hb562a.png" alt=""></figure>
<h4 id="mn-1">m=n-1</h4>
<p>当m=n-1时，图也就变成了一棵树</p>
<p>也就是这个亚子的。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/31njzxcr.png" alt=""></figure>
<p>（滑稽</p>
<p>那么小Y所要求的旅行方案就是这棵树字典序最小的DFS序。</p>
<p>字典序最小是题目要求的，不解释，那为什么是DFS呢？</p>
<p><strong>每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市</strong></p>
<p>你难道不觉得这很像DFS的遍历方式吗。</p>
<p>当你已经确定一个节点为下一个遍历目标的时候，你就一定要遍历完他的子树，否则一旦回溯，就再也回不来了。</p>
<p>反过来，DFS序就不用多解释了。如何遍历才能做到字典序最小呢？首先肯定要从节点1开始，否则直接输在起跑线上。然后呢？按照节点编号从小到大直接遍历就珂以了。</p>
<p>进一步说，如何保证从小到大的遍历顺序呢？如果你用邻接矩阵的话，请随意。如果是邻接表的话，排个序就行了。真的。</p>
<p>首先保证边（u，v）中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>&lt;</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u&lt;v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。</p>
<p>以u为第一关键字，v为第二关键字。从大到小排序。因为剖析邻接表的本质，存的边，相对于存进来时的边，他是倒序的。这样就保证了按照邻接表遍历的时候，是从小到大遍历的。</p>
<p>这也是我做这道题时，口胡的一种做法，应该对。</p>
<p>然后，我们可以那到60分的好成绩，<s>然而加上D1T1T2还是够不上SD的分数线</s></p>
<h4 id="mn">m=n</h4>
<p>当m=n时。</p>
<p>猜猜这叫什么，还是树。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/31njzxcr.png" alt=""></figure>
<p>（滑稽</p>
<p>但是他换了个名字，叫基环树，其实也就是树上多了个环。因为m=n。那该怎么做呢？我们之前有了树上的做法，所以我们可以把他变成树来做。一条边的事。</p>
<p>找环然后挨个删边，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>暴力。</p>
<p>找环的话就自己想想叭，挺简单的。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define N 500001
using namespace std;
int n,m,ans[N],res[N],txt,num1,num2;
int head[N],len;
int st[N],cnt;
bool vis[N],fis[N];
struct node{
	int to,nxt,r;
}eg[N*2];
struct note{
	int u,v;
}d[N*2];
bool cmp(const note a,const note b){
	if(a.u!=b.u) return a.u&gt;b.u;
	else return a.v&gt;b.v;
}
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].r=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
void find_ring(int u,int fa){//vis是否在环里，fis是否遍历过，eg[].r为边的编号
	fis[u]=true;
	for(int i=head[u];i;i=eg[i].nxt){
		int v=eg[i].to;
		if(eg[i].r!=fa&amp;&amp;fis[v]&amp;&amp;txt==0){
			vis[u]=true;
			txt=v;
		}
		else if(eg[i].r!=fa&amp;&amp;!fis[v]){
			find_ring(v,eg[i].r);
			if(vis[v]) vis[u]=true;
		}
	}
	if(vis[u]) st[++cnt]=u;
	if(u==txt) vis[u]=false;
} 
void dfs(int u,int fa){
	res[++txt]=u;
	for(int i=head[u];i;i=eg[i].nxt){
		int v=eg[i].to;
		if((u==num1&amp;&amp;v==num2)||(v==num1&amp;&amp;u==num2)) continue;
		if(v==fa) continue;
		dfs(v,u);
	}
}
void new_ans()
{
	if(ans[1]==0){
		for(int i=1;i&lt;=n;i++) ans[i]=res[i];
		return ;
	}
	for(int i=1;i&lt;=n;i++){
		if(res[i]&gt;ans[i]) break;
		if(res[i]&lt;ans[i]){
			for(int j=i;j&lt;=n;j++) ans[j]=res[j];
			return ;
		}
	}
	return ;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++) {
		scanf(&quot;%d%d&quot;,&amp;d[i].u,&amp;d[i].v);
		if(d[i].u&gt;d[i].v) swap(d[i].u,d[i].v);
	}
	sort(d+1,d+1+m,cmp);
	for(int i=1;i&lt;=m;i++) add(d[i].u,d[i].v,i),add(d[i].v,d[i].u,i); 
	if(m==n-1){
		dfs(1,1);
		for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,res[i]);
	}
	else{
		find_ring(1,-1);
		for(int i=1;i&lt;=cnt;i++){
			txt=0;
			if(i==cnt) num1=st[cnt],num2=st[1];
			else num1=st[i],num2=st[i+1];
			dfs(1,1);
			new_ans(); 
		}
		for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]);
	}
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>这个找环也是我之前做一道基环树题时口胡的做法。所以这篇题解珂以说是口胡系列。</p>
</div>
                              <div class="mdui-divider mdui-m-t-3"></div>
                              <div class="mdui-row-xs-2 mdui-m-t-2">
  <div class="mdui-col"> </div>
 <div class="mdui-col"><div class="mdui-text-right "><a href="https://Kite-chaser.github.io/post/p1272-chong-jian-dao-lu">P1272 重建道路</a></div> </div>
                                </div>
                                <div class="mdui-divider mdui-m-t-2"></div>
   
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '761ba32522ad16d2134b',
    clientSecret: 'd5634ea03ca976d589a06f88c4e9fb23c928e5f9',
    repo: 'Kite-chaser.github.io',
    owner: 'Kite-chaser',
    admin: ['Kite-chaser'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        
 <script src="https://Kite-chaser.github.io/media/scripts/Valine.min.js"></script>
 <div class="comment"></div>

<script>
      new Valine({
            el: '.comment',



            path: window.location.pathname,
            pageSize: 30,
            avatar:'mm', 
       })

    </script> 
<script>
    if(window.location.hash){
        var checkExist = setInterval(function() {
           if ($(window.location.hash).length) {
              $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
              clearInterval(checkExist);
           }
        }, 100);
    }
</script>
                         </article>
                 <div class="toc-container mdui-float-right">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a></li>
<li><a href="#solve">Solve</a>
<ul>
<li><a href="#mn-1">m=n-1</a></li>
<li><a href="#mn">m=n</a></li>
</ul>
</li>
<li><a href="#code">Code</a></li>
<li><a href="#%E5%90%8E%E8%A8%80">后言</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>

                        </div>
                 </div>
          
        </div>
        <script data-no-instant>
    (function ($) {
        $.extend({
            adamsOverload: function () {
                $.viewImage({
                    'target'  : '.post-neirong img',
                    'exclude' : '.vsmile-icons img , .song-links-item img',
                    'delay'   : 300
                });
            }
        });
    })(jQuery);
    jQuery.adamsOverload();
</script>
        <footer class="footer mdui-m-t-5 mdui-text-center">
               <nav class="social-links">
                      <ul>
                      
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                      </ul>
                    </nav>
                  <div class="copyright">
                      <p>Powered by Gridea</p>
                  </div>
              </footer>
    </body>
</html>