<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Kite-chaser.github.io</id>
    <title>Kite-chaser</title>
    <updated>2019-10-31T13:14:59.582Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Kite-chaser.github.io"/>
    <link rel="self" href="https://Kite-chaser.github.io/atom.xml"/>
    <subtitle>This is my blog.</subtitle>
    <logo>https://Kite-chaser.github.io/images/avatar.png</logo>
    <icon>https://Kite-chaser.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Kite-chaser</rights>
    <entry>
        <title type="html"><![CDATA[P1072 Hankson 的趣味题]]></title>
        <id>https://Kite-chaser.github.io/post/p1072-hankson-de-qu-wei-ti</id>
        <link href="https://Kite-chaser.github.io/post/p1072-hankson-de-qu-wei-ti">
        </link>
        <updated>2019-10-31T12:38:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>Hanks 博士是 BT(Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。</p>
<p>今天在课堂上，老师讲解了如何求两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>设某未知正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>满足：</p>
<p>1.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最大公约数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；<br>
2.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最小公倍数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>Hankson 的“逆问题”就是求出满足条件的正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。但稍加思索之后，他发现这样的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的个数。请你帮助他编程求解这个问题。</p>
<h3 id="solve">Solve</h3>
<p>1、</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x,a_0)=a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">lcm(x,b_0)=b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</blockquote>
<p>2、</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mo>&gt;</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mi mathvariant="normal">/</mi><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(x,a_0)=a_1=&gt;gcd(x/a_1,a_0/a_1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</blockquote>
<p>3、</p>
<blockquote>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">gcd(a,b)*lcm(a,b)=a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span><br>
所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x,b_0)*lcm(x,b_0)=x*b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">gcd(x,b_0)=x*b_0/lcm(x,b_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x,b_0)=x*b_0/b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>b</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x*b_1,b_0*b_1)=x*b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><msub><mi>b</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(b_1/b_0,b_1/x)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</blockquote>
<p>4、</p>
<blockquote>
<p>同时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1|x,x|b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>解法也就出来了。<br>
枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的因数，然后判断是否符合结论。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
int n;
int a,b,c,d;
int ans;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	while(n--){
		ans=0;
		scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		for(int x=1;x*x&lt;=d;x++){
			int y=d/x;
			if(d%x!=0) continue;
			if(x%b==0&amp;&amp;gcd(x/b,a/b)==1&amp;&amp;gcd(d/c,d/x)==1) ans++;
			if(x==y) continue;
			if(y%b==0&amp;&amp;gcd(y/b,a/b)==1&amp;&amp;gcd(d/c,d/y)==1) ans++;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散化]]></title>
        <id>https://Kite-chaser.github.io/post/chi-san-hua</id>
        <link href="https://Kite-chaser.github.io/post/chi-san-hua">
        </link>
        <updated>2019-10-31T10:56:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>离散化是程序设计中一个常用的技巧，它可以有效的降低时间复杂度。其基本思想就是在众多可能的情况中，只考虑需要用的值。离散化可以改进一个低效的算法，甚至实现根本不可能实现的算法。要掌握这个思想，必须从大量的题目中理解此方法的特点。例如，在建造线段树空间不够的情况下，可以考虑离散化。</p>
<h3 id="正文">正文</h3>
<p>离散化的使用在OI中使用十分广泛，主要用于数据的处理，那么他到底是个什么东西呢？</p>
<p>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小，将无穷大集合中的若干个元素映射为有限集合以便于统计。</p>
<p>假设问题涉及int范围内的n个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,这n个整数可能有重复，去重以后共有m个整数。我们要把每个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用一个1~m之间的整数代替，并且保持大小顺序不变，即如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>x小于（或等于、大于），那么代替<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的整数也小于（或等于、大于）代替<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的整数。</p>
<p>例如：</p>
<p>原数据：1,999,100000,15；处理后：1,3,4,2；</p>
<p>原数据：{100,200}，{20,50000}，{1,400}；</p>
<p>处理后：{3,4}，{2,6}，{1,5}；</p>
<p>离散化也是各种排序算法的一个应用。</p>
<p>离散化的思路也十分简单， 先排序，再删除重复元素，最后就是索引元素离散化后对应的值。</p>
<h4 id="code">Code</h4>
<pre><code class="language-cpp">void discrete(){// 或用STL中的unique
    sort(a+1,a+n+1);
    for(int i=1;i&lt;=n;i++){
        if(i==1||a[i]!=a[i-1]) b[++m]=a[i];
	}
}
int query(int x){//查询x映射为1~m之间那个整数
	return lower_bound(b+1,b+m+1,x)-b;
}
</code></pre>
<h3 id="关于lower_bound">关于lower_bound</h3>
<p>查找不小于x的元素中最小的一个，并返回指向该元素的迭代器（可以简单的理解为位置？）</p>
<h3 id="后言">后言</h3>
<p>生活中的“离散化”的例子还有很多，比如某一中的班级名单，按照学生的成绩排个序，然后从一号开始标，班级内的序号也就是班级内的排名。这也就避免了成绩的差距过大，比如我友链中那几个强者和我这样的菜鸡。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1955 [NOI2015]程序自动分析]]></title>
        <id>https://Kite-chaser.github.io/post/p1955-noi2015cheng-xu-zi-dong-fen-xi</id>
        <link href="https://Kite-chaser.github.io/post/p1955-noi2015cheng-xu-zi-dong-fen-xi">
        </link>
        <updated>2019-10-31T10:53:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p>
<p>考虑一个约束满足问题的简化版本：假设x1,x2,x3...代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p>
<p>现在给出一些约束满足问题，请分别对它们进行判定。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1955">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>简单点说，就是用并查集莽就完了。</p>
<p>用每个x做节点，然后，先检查等于的情况，将其中的x合并到一个集合中，最后检查不等于的情况，如果在一个集合内就是“NO”，如果都不在一个集合内就是“YES”。</p>
<p>但是有趣的是x的范围是10e9的，这要是做数组下标，那么一大堆MLE和CE都等着你，当场毙命。</p>
<p>于是我们理性的分析分析，虽然范围大，但是每次最多有2*n个数字不同，所以你懂我意思吧。</p>
<p><a href="https://kite-chaser.github.io/post/chi-san-hua">离散化</a>。</p>
<p>数据问题解决了，面前就是一马平川，莽！<strong>注意是多组数据，记得重置。</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define N 2100000
using namespace std;
int t,n;
int fa[N];
int num[N],cnt,len1,len2,op,b[N];
int x,y,z;
bool flag;
struct note{
	int u,v,w;
}d[N];
int find(int s){
	if(fa[s]!=s) fa[s]=find(fa[s]);
	return fa[s];
}
int query(int s){
	return lower_bound(b+1,b+op+1,s)-b;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;t);
	while(t--){
		scanf(&quot;%d&quot;,&amp;n);
		cnt=0;op=0;len1=0;len2=n+1;flag=false;
		for(int i=1;i&lt;=2*n;i++) fa[i]=i;
		for(int i=1;i&lt;=n;i++){
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			num[++cnt]=x; 
			num[++cnt]=y;
			if(z) d[++len1].u=x,d[len1].v=y,d[len1].w=z;
			else d[--len2].u=x,d[len2].v=y,d[len2].w=z;
            //两个“指针”，两边放。
		}
		sort(num+1,num+1+cnt);
		for(int i=1;i&lt;=cnt;i++){
			if(i==1||num[i]!=num[i-1]) b[++op]=num[i];
		}
		for(int i=1;i&lt;=n;i++)d[i].u=query(d[i].u),d[i].v=query(d[i].v); 
		for(int i=1;i&lt;=n;i++){
			int e=find(d[i].u),r=find(d[i].v);
			if(d[i].w){
				if(e!=r) fa[r]=e;
			}
			else{
				if(e==r){flag=true;printf(&quot;NO\n&quot;);break;}
			}
		}
		if(!flag) printf(&quot;YES\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>小心用map，反正我的死了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[论GCD的玄学使用]]></title>
        <id>https://Kite-chaser.github.io/post/lun-gcd-de-xuan-xue-shi-yong</id>
        <link href="https://Kite-chaser.github.io/post/lun-gcd-de-xuan-xue-shi-yong">
        </link>
        <updated>2019-10-30T13:49:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>欧几里德算法又称辗转相除法是指用于计算两个正整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。</p>
<p>这是gcd的本职工作，代码也比较简单，证明就不再多解释。</p>
<h4 id="code">Code</h4>
<pre><code class="language-cpp">int gcd(int a,int b){
	return b?gcd(b,a%b):a;
}
</code></pre>
<h3 id="正文">正文</h3>
<p>接下来本文要讲的，才是gcd的<s>正确</s>打开方式。</p>
<p>OIer经常遇到这样的问题，就是如何判断在一个平面直角坐标系中或近似于平面直角坐标系中，判断两点之间有无其他整数点（横坐标和纵坐标都为整数的点），甚至让你求出具体个数。</p>
<p>比如这道例题。</p>
<h3 id="eg">EG</h3>
<h4 id="p1447-noi2010能量采集"><a href="https://www.luogu.org/problem/P1447">P1447 [NOI2010]能量采集</a></h4>
<h4 id="题目描述">题目描述</h4>
<p>栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。</p>
<p>栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。</p>
<p>由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。</p>
<p>能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能 量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。</p>
<p>下面给出了一个能量采集的例子，其中n = 5，m = 4，一共有20棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。</p>
<h4 id="solve">Solve</h4>
<p>一般来说，大多数写题解的人，会直接告诉你这个奇怪的结论。</p>
<p><strong>一个点（x,y）到原点之间的整数点个数即为gcd（x，y），包括（x,y)不包括原点，也就是k+1。</strong></p>
<p>之前我试了试之后发现这竟然是对的，但是不知道为什么是对的。翻遍有关的题解和资料都没有详细的解释。于是秉着<s>万丈高楼平地起，成功只能靠自己</s>认真的原则，就自己探求了一下，终于探求到其中的一点奥秘，与大家分享下。</p>
<p>其实也不是多么高深的东西。</p>
<p>首先，将一个整数点（x，y）看作一个直角三角形或是一个矩形，边长为x和y。称他为三角形或矩形（x，y）。</p>
<p>然后，设gcd（x，y）=d，那么三角形（x/d，y/d）也是直角边为整数的三角形。</p>
<p>那么，x和y分别乘上d分之一，d分之二……直到d分之d。这其中所有的三角形的直角边边长都是整数，对应到平面直角坐标系上就是d个点，这一点可以<s>性感</s>感性理解一下，或想想三角形的相似，就可以明白了。</p>
<p>所以，<strong>一个点（x,y）到原点之间的整数点个数即为gcd（x，y），包括（x,y)不包括原点，也就是k+1。</strong></p>
<p>这样再去分析类似的题目，就不会那么难搞了，<s>也能看懂题解了。</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2845 [USACO15DEC]Switching on the Lights 开关灯]]></title>
        <id>https://Kite-chaser.github.io/post/p2845-usaco15decswitching-on-the-lights-kai-guan-deng</id>
        <link href="https://Kite-chaser.github.io/post/p2845-usaco15decswitching-on-the-lights-kai-guan-deng">
        </link>
        <updated>2019-10-29T11:45:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目背景">题目背景</h3>
<p>来源：usaco-2015-dec</p>
<p>Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个N*N的矩形网络。（1&lt;n&lt;100)</p>
<p>然而bessie十分怕黑，他想计算可以把多少个牛棚的灯打开。</p>
<h3 id="题目描述">题目描述</h3>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个房间，组成了一张<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的网格图，Bessie一开始位于左上角(1,1)，并且只能上下左右行走。</p>
<p>一开始，只有(1,1)这个房间的灯是亮着的，Bessie只能在亮着灯的房间里活动。</p>
<p>有另外M条信息，每条信息包含四个数a,b,c,d，表示房间(a,b)里有房间(c,d)的灯的开关。</p>
<p>请计算出最多有多少个房间的灯可以被打开</p>
<h3 id="说明提示">说明/提示</h3>
<p>这里，如果你看得懂英文的话，这里有样例的说明。</p>
<p>Here, Bessie can use the switch in (1,1)to turn on lights in (1,2)and (1,3). She can then walk to (1,3)and turn on the lights in (2,1)，from which she can turn on the lights in (2,2). The switch in (2,3)is inaccessible to her, being in an unlit room. She can therefore illuminate at most 5 rooms.</p>
<h3 id="手动机翻">手动机翻</h3>
<p>在这里，贝茜可以使用 （1，1） 中的开关打开 （1，2） 和 （1，3） 中的灯。然后，她可以步行到（1，3）并打开（2，1）中的灯，从中她可以打开灯（2，2）。她无法进入（2，3）的开关，她住在一间没有照明的房间里。因此，她最多能照亮5个房间。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2845">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>BFS莽就完了。<br>
就是得注意不是找几个房间可以走到，而是可以开几个房间的灯。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define N 1000
using namespace std;
int n,m,ans;
int x1,y1,x2,y2;
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
struct note{
	int x,y;
};
vector&lt;note&gt; g[N][N];
queue&lt;note&gt; q;
bool vis[N][N],fis[N][N];//vis是否房间开灯，fis是否被走到
void bfs(){
	q.push((note){1,1});vis[1][1]=true;fis[1][1]=true;ans=1;
	while(!q.empty()){
		note e=q.front();
		q.pop();
		int x=e.x,y=e.y;
		for(int i=0;i&lt;g[x][y].size();i++){
			int xx=g[x][y][i].x,yy=g[x][y][i].y;
			if(!vis[xx][yy]){
				vis[xx][yy]=true;
				ans++;
			}
			if((fis[xx-1][yy]||fis[xx][yy+1]||fis[xx+1][yy]||fis[xx][yy-1])&amp;&amp;!fis[xx][yy]) fis[xx][yy]=true,q.push((note){xx,yy});
		}
		for(int i=0;i&lt;4;i++){
			int xx=x+dx[i],yy=y+dy[i];
			if(!fis[xx][yy]&amp;&amp;vis[xx][yy]){
				fis[xx][yy]=true;
				q.push((note){xx,yy});
			}
		}
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		g[x1][y1].push_back((note){x2,y2});
	}
	bfs();
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>附带一段神奇编译。</p>
<blockquote>
<p>/tmp/tmpv278mza7/src: 在函数‘void bfs()’中:<br>
/tmp/tmpv278mza7/src:24:16: 警告：comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<note>::size_type’ {aka ‘long unsigned int’}    [-Wsign-compare]<br>
for(int i=0;i&lt;g[x][y].size();i++){<br>
<sub>^</sub>~~~~~~~~~~~~~</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4588 [TJOI2018]数学计算]]></title>
        <id>https://Kite-chaser.github.io/post/p4588-tjoi2018shu-xue-ji-suan</id>
        <link href="https://Kite-chaser.github.io/post/p4588-tjoi2018shu-xue-ji-suan">
        </link>
        <updated>2019-10-29T11:26:21.000Z</updated>
        <summary type="html"><![CDATA[<p>这真的是道线段树……</p>
]]></summary>
        <content type="html"><![CDATA[<p>这真的是道线段树……</p>
<!--more-->
<h3 id="题目描述">题目描述</h3>
<p>小豆现在有一个数x，初始值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.小豆有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>次操作，操作有两种类型:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>m</mi><mo>:</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1m:x=x\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>%mod;</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>p</mi><mi>o</mi><mi>s</mi><mo>:</mo><mi>x</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">2pos:x=x/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">/</span></span></span></span>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>次操作所乘的数（保证第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>次操作一定为类型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,对于每一个类型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的操作至多会被除一次）输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x%mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>;</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P4588">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>说实话，一开始我是真没看出来这是道线段树。<br>
以每一个时间节点作为叶子节点，，初始值都是1，区间求乘。</p>
<ul>
<li>1操作就是在相应的时间节点，修改为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</li>
<li>2操作就是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>位置修改为1.</li>
</ul>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 100010
#define ll long long
using namespace std;
ll t;
ll Q,mod;
ll st[N],cnt;
struct note{
	ll l,r,num;
}d[N*4];
ll op,pos;
void build(ll k,ll x,ll y){
	d[k].l=x;d[k].r=y;d[k].num=1; 
	if(x==y) return ;
	build(k*2,x,(x+y)/2);
	build(k*2+1,(x+y)/2+1,y);
}
void revise(ll k,ll x,ll z){
	if(d[k].l==d[k].r){
		d[k].num=z%mod;
		return ;
	}
	ll mid=(d[k].l+d[k].r)/2;
	if(x&lt;=mid) revise(k*2,x,z);
	else revise(k*2+1,x,z);
	d[k].num=(d[k*2].num*d[k*2+1].num)%mod;
}
int main()
{
	scanf(&quot;%lld&quot;,&amp;t);
	while(t--){
		scanf(&quot;%lld%lld&quot;,&amp;Q,&amp;mod);
		build(1,1,Q);
		for(ll i=1;i&lt;=Q;i++){
			scanf(&quot;%lld%lld&quot;,&amp;op,&amp;pos);
			if(op==1) revise(1,i,pos);
			else revise(1,pos,1);
			printf(&quot;%lld\n&quot;,d[1].num);
		}
	}
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>话说有大佬说，这个题不用建树，直接莽就行。<s>可是不建树还是线段树吗？🙃</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[神奇的图]]></title>
        <id>https://Kite-chaser.github.io/post/shen-qi-de-tu</id>
        <link href="https://Kite-chaser.github.io/post/shen-qi-de-tu">
        </link>
        <updated>2019-10-29T11:22:01.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Kite-chaser.github.io/post-images/1572348146460.jpg" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UVA1753 Need for Speed]]></title>
        <id>https://Kite-chaser.github.io/post/uva1753-need-for-speed</id>
        <link href="https://Kite-chaser.github.io/post/uva1753-need-for-speed">
        </link>
        <updated>2019-10-28T12:11:38.000Z</updated>
        <summary type="html"><![CDATA[<p>OIer写代码，总会遇到几个玄学错误。</p>
]]></summary>
        <content type="html"><![CDATA[<p>OIer写代码，总会遇到几个玄学错误。</p>
<!--more-->
<h3 id="题意描述">题意描述</h3>
<p>Winniechen有一辆车， 但是它的迈速表指针坏掉的。当度数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>的时候， 车的实际速度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">s+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>是一个不确定的实数（常数。现在给你一段行程，包含n个路段， 保证每个路段是均速行驶的， 每个描述有两个数字， 分别为行驶的路程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和迈速表的读数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。整个行程一共用了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的时间， 请确定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>的值。另外请注意， 他的真实速度是永远保持在0以上的。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/UVA1753">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>首先，我们蒙一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>做答案。<br>
<img src="https://Kite-chaser.github.io/post-images/1572265247371.png" alt=""><br>
然后试一试，如果用时超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的话，就是速度太慢了，应该给他提提速。如果小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的话，就是速度太快了，应该给他降一降，如果用时等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的话，bingo，恭喜你猜对了。<br>
所以，我们惊奇的发现，这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>具有“单调性”，这意味着什么？我们可以有规律地去猜。<br>
二分答案。而判断就是用用时与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的关系。<br>
<strong>特殊之处就在于，是实数域上的二分。</strong><br>
无非就是把</p>
<pre><code class="language-cpp">while(l&lt;=r){
	mid=(l+r)&gt;&gt;1;
	if(···) l=mid+1;
	else r=mid-1; 
} 
</code></pre>
<p>换成</p>
<pre><code class="language-cpp">while(l&lt;=r-eps){
	mid=(l+r)/2;
	if(···) l=mid;
	else r=mid; 
} 
</code></pre>
<p>所有变量都是double类型。<strong>eps就是你想要卡的精度。</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 100000
#define db double
using namespace std;
int n;
db s[N],d[N];
db t,sum;
db l,r,mid,eps=1e-9;//就是这个
bool solve(db c){
	sum=0;
	for(int i=1;i&lt;=n;i++){
		if(s[i]+c&lt;=0) return true;//如果速度小于0的话就跟就GG了
		sum+=(d[i]/(s[i]+c)); 
	}
	if(sum&gt;t) return true;
	else return false;
}
int main()
{
	while(scanf(&quot;%d%lf&quot;,&amp;n,&amp;t)!=EOF){//记住这个“！=EOF”
		l=-20000000,r=20000000;
		for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;d[i],&amp;s[i]);
		for(int i=1;i&lt;=100;i++){
			mid=(l+r)/2;
			if(solve(mid)) l=mid;
			else r=mid;
		}
		printf(&quot;%.9lf\n&quot;,l);
	}
}
</code></pre>
<h3 id="后言">后言</h3>
<p>我原以为加不加EOF都一样的，或者是“~”取反，但是某谷给了我一个大大的耳光，我T飞了。<br>
所以观察答案有“单调性”的话，二分莽就完了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1948 [USACO08JAN]电话线Telephone Lines]]></title>
        <id>https://Kite-chaser.github.io/post/p1948-usaco08jandian-hua-xian-telephone-lines</id>
        <link href="https://Kite-chaser.github.io/post/p1948-usaco08jandian-hua-xian-telephone-lines">
        </link>
        <updated>2019-10-27T13:19:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system.</p>
<p>There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John's property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart.</p>
<p>The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used.</p>
<p>As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables.</p>
<p>Determine the minimum amount that Farmer John must pay.</p>
<p>多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着N(1&lt;=N&lt;=1000)根据1……n顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有p(1&lt;=p&lt;=10000)对电话杆可以拉电话线。其他的由于地震使得无法连接。</p>
<p>第i对电线杆的两个端点分别是ai,bi，它们的距离为li(1&lt;=li&lt;=1000000)。数据中每对(ai,bi)只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。</p>
<p>电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0.</p>
<p>请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1948">原题链接</a></p>
</blockquote>
<h2 id="solve">Solve</h2>
<p>一眼，这不就是分层图裸题吗？但是这个范围。<br>
虽然我没试过，但是这个范围会GG。于是我放弃了分层图。（其实有心的同学可以试一试。<br>
那么仔细分析一下这道题，发现求解的不是最小总代价，而是最小代价。而且这个代价是具有单调性的。<br>
也就是说，一个最小代价为x的可行情况，那么大于x的情况也可行。<br>
这就很明白了，二分答案。二分最小代价。<br>
那如何判断呢？想一想，拿当然是最短路惹。DJ，SPFA，乃至BFS都可以。<br>
我个人比较喜欢DJ。</p>
<p>众所周知<br>
<img src="https://Kite-chaser.github.io/post-images/1572183195997.png" alt=""><br>
其实这个题，SPFA也可以啦。<br>
解法也就出来了。<br>
二分答案+DJ/SPFA</p>
<ul>
<li>大于mid的边权设为1，小于等于mid的权值设为0。</li>
<li>跑最短路。</li>
<li>如果dis[n]&lt;=k的话就是可行的情况。</li>
</ul>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define N 100000
using namespace std;
int n,m,k;
int l=0,r=100000,mid,ans=-1;
int dis[N];
int u,v,w;
int head[N],len;
bool vis[N];
struct note{
	int to,vl,nxt;
}eg[N];
struct node{
	int u,vl;
	bool operator&lt;(const node &amp;a)const{
		return a.vl&lt;vl;
	}
};
priority_queue&lt;node&gt; q;
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].vl=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
bool dj(int s){
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;q.push((node){1,0});
	while(!q.empty()){
		int e=q.top().u;
		q.pop();
		vis[e]=false;
		for(int i=head[e];i;i=eg[i].nxt){
			int v=eg[i].to;
			int dist;
			if(eg[i].vl&gt;s) dist=1;
			else dist=0;
			if(dis[v]&gt;dis[e]+dist){
				dis[v]=dis[e]+dist;
				if(!vis[v]) vis[v]=true,q.push((node){v,dis[v]});
			}
		}
	}
	if(dis[n]&lt;=k) return true;
	else return false;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);add(v,u,w);
		r=max(r,w);
	}
	while(l&lt;=r){
		int mid=(l+r)&gt;&gt;1;
		if(dj(mid)){
			r=mid-1;
			ans=mid;
		}
		else l=mid+1;
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h2 id="后言">后言</h2>
<p>答案单调的二分莽就完了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分约束]]></title>
        <id>https://Kite-chaser.github.io/post/chai-fen-yue-shu</id>
        <link href="https://Kite-chaser.github.io/post/chai-fen-yue-shu">
        </link>
        <updated>2019-10-27T11:16:11.000Z</updated>
        <summary type="html"><![CDATA[<p>图论真的是博大精深。</p>
]]></summary>
        <content type="html"><![CDATA[<p>图论真的是博大精深。</p>
<!--more-->
<h2 id="前言">前言</h2>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。<br>
求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。</p>
<h2 id="正文">正文</h2>
<p>观察xj-xi&lt;=bk，会发现它类似最短路中的三角不等式d[v]&lt;=d[u]+w[u,v]，即d[v]-d[u]&lt;=w[u,v]。因此，以每个变量xi为结点，对于约束条件xj-xi&lt;=bk，连接一条边(i,j)，边权为bk。我们再增加一个源点s,s与所有定点相连，边权均为0。对这个图，以s为源点运行Bellman-ford算法（或SPFA算法），最终{d[ i]}即为一组可行解。<br>
例：d[x]-d[y]&gt;=Z<br>
如果想连边后求最长路 那么将不等式变形为这种形式 d[x]&gt;=d[y]+z y---x连一条权值为z的边<br>
求最短路则变形成d[y]&lt;=d[x]-z x---y连一条权值为-z的边。<br>
如果是别的不等式，也可以根据情况变形。<br>
为什么一定要用SPFA呢，因为这个系统可能无解。当最长路出现正环的时候或最短路出现负环的时候，这个系统就无解惹。其实，最长最短都差不多，视情况而定。</p>
<h2 id="eg">EG</h2>
<h3 id="p1993-小k的农场"><a href="https://www.luogu.org/problem/P1993">P1993 小K的农场</a></h3>
<h3 id="题目描述">题目描述</h3>
<p>小K在MC里面建立很多很多的农场，总共n个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共m个），以下列三种形式描述：</p>
<ul>
<li>农场a比农场b至少多种植了c个单位的作物，</li>
<li>农场a比农场b至多多种植了c个单位的作物，</li>
<li>农场a与农场b种植的作物数一样多。</li>
</ul>
<p>但是，由于小K的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。</p>
<h3 id="solve">Solve</h3>
<p>建图，求最长路。</p>
<ul>
<li>a-b&gt;=c,从b向a建一条边权为c的边。</li>
<li>a-b&lt;=c等于b-a&lt;=-c,从a向b建一条边权为-c的边。</li>
<li>a=b，等于a-b&gt;=0或b-a&gt;=0，双向建边，权值为0。<br>
每种情况分析完毕。<br>
超级源点为0。向每一个点建一条权值为0的边。<br>
SPFA跑最长路。<br>
<strong>一种玄学优化方式，用DFS优化SPFA，直接跑SPFA会T飞的。</strong><br>
<strong>在判负环中可以用DFS或用栈代替队列来优化SPFA，但是在没有负环的情况请小心使用。</strong></li>
</ul>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=23333333;
const int N=50005;
int n,m;
int num,x,y,z;
int first[N],nxt[N],to[N],dist[N],len;
int cnt[N],dis[N];
bool vis[N];
inline int read(){
    int k=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        k=(k&lt;&lt;1)+(k&lt;&lt;3)+(ch^48);
        ch=getchar();
    }
    return k*f;
}
void add(int u,int v,int w){
	to[++len]=v;
	dist[len]=w;
	nxt[len]=first[u];
	first[u]=len;
}
bool spfa(int u){
	vis[u]=1;
	for(int i=first[u];i!=-1;i=nxt[i]){
		if(dis[to[i]]&lt;dis[u]+dist[i]){
			dis[to[i]]=dis[u]+dist[i];
			if(vis[to[i]]) return 0;
			if(!spfa(to[i])) return 0;
		}
	}
	vis[u]=0;
	return 1;
}
int main()
{
	memset(first,-1,sizeof(first));
	n=read();m=read();
	for(int i=1;i&lt;=m;i++){
		num=read();x=read();y=read();
		if(num==1) z=read(),add(y,x,z);
		else if(num==2) z=read(),add(x,y,-z);
		else if(num==3) add(x,y,0),add(y,x,0);
	}
	for(int i=1;i&lt;=n;i++) add(0,i,0),dis[i]=-maxn;;
	if(spfa(0)) printf(&quot;Yes&quot;);
	else printf(&quot;No&quot;);
	return 0;
} 
</code></pre>
<h2 id="后言">后言</h2>
<p>由此观之，许多看似后无头绪的题，其实可以用图论解决。就好像有指向性的状态可以用DAG建模。然后用相应的图论方法解决。所以OI题也要注意建模。</p>
<h2 id="相关例题">相关例题</h2>
<p><a href="https://www.luogu.org/problem/P2294">P2294 [HNOI2005]狡猾的商人</a><br>
<a href="https://www.luogu.org/problem/P3275">P3275 [SCOI2011]糖果</a><br>
<a href="https://www.luogu.org/problem/P3084">P3084 [USACO13OPEN]照片Photo</a><br>
<a href="https://www.luogu.org/problem/P4878">P4878 [USACO05DEC] 布局</a></p>
]]></content>
    </entry>
</feed>