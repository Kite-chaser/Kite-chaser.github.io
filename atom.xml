<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Kite-chaser.github.io</id>
    <title>Kite-chaser</title>
    <updated>2019-10-28T11:27:08.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Kite-chaser.github.io"/>
    <link rel="self" href="https://Kite-chaser.github.io/atom.xml"/>
    <subtitle>This is my blog.</subtitle>
    <logo>https://Kite-chaser.github.io/images/avatar.png</logo>
    <icon>https://Kite-chaser.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Kite-chaser</rights>
    <entry>
        <title type="html"><![CDATA[P1948 [USACO08JAN]电话线Telephone Lines]]></title>
        <id>https://Kite-chaser.github.io/post/p1948-usaco08jandian-hua-xian-telephone-lines</id>
        <link href="https://Kite-chaser.github.io/post/p1948-usaco08jandian-hua-xian-telephone-lines">
        </link>
        <updated>2019-10-27T13:19:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system.</p>
<p>There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John's property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart.</p>
<p>The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used.</p>
<p>As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables.</p>
<p>Determine the minimum amount that Farmer John must pay.</p>
<p>多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着N(1&lt;=N&lt;=1000)根据1……n顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有p(1&lt;=p&lt;=10000)对电话杆可以拉电话线。其他的由于地震使得无法连接。</p>
<p>第i对电线杆的两个端点分别是ai,bi，它们的距离为li(1&lt;=li&lt;=1000000)。数据中每对(ai,bi)只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。</p>
<p>电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0.</p>
<p>请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1948">原题链接</a></p>
</blockquote>
<h2 id="solve">Solve</h2>
<p>一眼，这不就是分层图裸题吗？但是这个范围。<br>
虽然我没试过，但是这个范围会GG。于是我放弃了分层图。（其实有心的同学可以试一试。<br>
那么仔细分析一下这道题，发现求解的不是最小总代价，而是最小代价。而且这个代价是具有单调性的。<br>
也就是说，一个最小代价为x的可行情况，那么大于x的情况也可行。<br>
这就很明白了，二分答案。二分最小代价。<br>
那如何判断呢？想一想，拿当然是最短路惹。DJ，SPFA，乃至BFS都可以。<br>
我个人比较喜欢DJ。</p>
<p>众所周知<br>
<img src="https://Kite-chaser.github.io/post-images/1572183195997.png" alt=""><br>
其实这个题，SPFA也可以啦。<br>
解法也就出来了。<br>
二分答案+DJ/SPFA</p>
<ul>
<li>大于mid的边权设为1，小于等于mid的权值设为0。</li>
<li>跑最短路。</li>
<li>如果dis[n]&lt;=k的话就是可行的情况。</li>
</ul>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define N 100000
using namespace std;
int n,m,k;
int l=0,r=100000,mid,ans=-1;
int dis[N];
int u,v,w;
int head[N],len;
bool vis[N];
struct note{
	int to,vl,nxt;
}eg[N];
struct node{
	int u,vl;
	bool operator&lt;(const node &amp;a)const{
		return a.vl&lt;vl;
	}
};
priority_queue&lt;node&gt; q;
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].vl=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
bool dj(int s){
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;q.push((node){1,0});
	while(!q.empty()){
		int e=q.top().u;
		q.pop();
		vis[e]=false;
		for(int i=head[e];i;i=eg[i].nxt){
			int v=eg[i].to;
			int dist;
			if(eg[i].vl&gt;s) dist=1;
			else dist=0;
			if(dis[v]&gt;dis[e]+dist){
				dis[v]=dis[e]+dist;
				if(!vis[v]) vis[v]=true,q.push((node){v,dis[v]});
			}
		}
	}
	if(dis[n]&lt;=k) return true;
	else return false;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);add(v,u,w);
		r=max(r,w);
	}
	while(l&lt;=r){
		int mid=(l+r)&gt;&gt;1;
		if(dj(mid)){
			r=mid-1;
			ans=mid;
		}
		else l=mid+1;
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h2 id="后言">后言</h2>
<p>答案单调的二分莽就完了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分约束]]></title>
        <id>https://Kite-chaser.github.io/post/chai-fen-yue-shu</id>
        <link href="https://Kite-chaser.github.io/post/chai-fen-yue-shu">
        </link>
        <updated>2019-10-27T11:16:11.000Z</updated>
        <summary type="html"><![CDATA[<p>图论真的是博大精深。</p>
]]></summary>
        <content type="html"><![CDATA[<p>图论真的是博大精深。</p>
<!--more-->
<h2 id="前言">前言</h2>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。<br>
求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。</p>
<h2 id="正文">正文</h2>
<p>观察xj-xi&lt;=bk，会发现它类似最短路中的三角不等式d[v]&lt;=d[u]+w[u,v]，即d[v]-d[u]&lt;=w[u,v]。因此，以每个变量xi为结点，对于约束条件xj-xi&lt;=bk，连接一条边(i,j)，边权为bk。我们再增加一个源点s,s与所有定点相连，边权均为0。对这个图，以s为源点运行Bellman-ford算法（或SPFA算法），最终{d[ i]}即为一组可行解。<br>
例：d[x]-d[y]&gt;=Z<br>
如果想连边后求最长路 那么将不等式变形为这种形式 d[x]&gt;=d[y]+z y---x连一条权值为z的边<br>
求最短路则变形成d[y]&lt;=d[x]-z x---y连一条权值为-z的边。<br>
如果是别的不等式，也可以根据情况变形。<br>
为什么一定要用SPFA呢，因为这个系统可能无解。当最长路出现正环的时候或最短路出现负环的时候，这个系统就无解惹。其实，最长最短都差不多，视情况而定。</p>
<h2 id="eg">EG</h2>
<h3 id="p1993-小k的农场"><a href="https://www.luogu.org/problem/P1993">P1993 小K的农场</a></h3>
<h3 id="题目描述">题目描述</h3>
<p>小K在MC里面建立很多很多的农场，总共n个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共m个），以下列三种形式描述：</p>
<ul>
<li>农场a比农场b至少多种植了c个单位的作物，</li>
<li>农场a比农场b至多多种植了c个单位的作物，</li>
<li>农场a与农场b种植的作物数一样多。</li>
</ul>
<p>但是，由于小K的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。</p>
<h3 id="solve">Solve</h3>
<p>建图，求最长路。</p>
<ul>
<li>a-b&gt;=c,从b向a建一条边权为c的边。</li>
<li>a-b&lt;=c等于b-a&lt;=-c,从a向b建一条边权为-c的边。</li>
<li>a=b，等于a-b&gt;=0或b-a&gt;=0，双向建边，权值为0。<br>
每种情况分析完毕。<br>
超级源点为0。向每一个点建一条权值为0的边。<br>
SPFA跑最长路。</li>
</ul>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=23333333;
const int N=50005;
int n,m;
int num,x,y,z;
int first[N],nxt[N],to[N],dist[N],len;
int cnt[N],dis[N];
bool vis[N];
inline int read(){
    int k=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        k=(k&lt;&lt;1)+(k&lt;&lt;3)+(ch^48);
        ch=getchar();
    }
    return k*f;
}
void add(int u,int v,int w){
	to[++len]=v;
	dist[len]=w;
	nxt[len]=first[u];
	first[u]=len;
}
bool spfa(int u){
	vis[u]=1;
	for(int i=first[u];i!=-1;i=nxt[i]){
		if(dis[to[i]]&lt;dis[u]+dist[i]){
			dis[to[i]]=dis[u]+dist[i];
			if(vis[to[i]]) return 0;
			if(!spfa(to[i])) return 0;
		}
	}
	vis[u]=0;
	return 1;
}
int main()
{
	memset(first,-1,sizeof(first));
	n=read();m=read();
	for(int i=1;i&lt;=m;i++){
		num=read();x=read();y=read();
		if(num==1) z=read(),add(y,x,z);
		else if(num==2) z=read(),add(x,y,-z);
		else if(num==3) add(x,y,0),add(y,x,0);
	}
	for(int i=1;i&lt;=n;i++) add(0,i,0),dis[i]=-maxn;;
	if(spfa(0)) printf(&quot;Yes&quot;);
	else printf(&quot;No&quot;);
	return 0;
} 
</code></pre>
<h2 id="后言">后言</h2>
<p>由此观之，许多看似后无头绪的题，其实可以用图论解决。就好像有指向性的状态可以用DAG建模。然后用相应的图论方法解决。所以OI题也要注意建模。</p>
<h2 id="相关例题">相关例题</h2>
<p><a href="https://www.luogu.org/problem/P2294">P2294 [HNOI2005]狡猾的商人</a><br>
<a href="https://www.luogu.org/problem/P3275">P3275 [SCOI2011]糖果</a><br>
<a href="https://www.luogu.org/problem/P3084">P3084 [USACO13OPEN]照片Photo</a><br>
<a href="https://www.luogu.org/problem/P4878">P4878 [USACO05DEC] 布局</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分层图]]></title>
        <id>https://Kite-chaser.github.io/post/fen-ceng-tu</id>
        <link href="https://Kite-chaser.github.io/post/fen-ceng-tu">
        </link>
        <updated>2019-10-27T02:17:58.000Z</updated>
        <summary type="html"><![CDATA[<p>黑科技。</p>
]]></summary>
        <content type="html"><![CDATA[<p>黑科技。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>分层图就是一种上层可以到达下层，而下层不可以到达上层的图。<br>
其实重要的是一种构图方法。<br>
<img src="https://Kite-chaser.github.io/post-images/1572143056945.png" alt=""><br>
如图，黑色的边就是一层图，蓝色的边就是上层连向下层的图。</p>
<h2 id="eg1">EG1</h2>
<h3 id="p2939-usaco09feb改造路revamping-trails"><a href="https://www.luogu.org/problem/P2939">P2939 [USACO09FEB]改造路Revamping Trails</a></h3>
<h3 id="题目描述">题目描述</h3>
<p>Farmer John dutifully checks on the cows every day. He traverses some of the M (1 &lt;= M &lt;= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 &lt;= N &lt;= 10,000) pastures conveniently numbered 1..N on Farmer John's farm are currently connected by bidirectional dirt trails. Each trail i connects pastures P1_i and P2_i (1 &lt;= P1_i &lt;= N; 1 &lt;= P2_i &lt;= N) and requires T_i (1 &lt;= T_i &lt;= 1,000,000) units of time to traverse.</p>
<p>He wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 &lt;= K &lt;= 20) trails to turn into highways, which will effectively reduce the trail's traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N.</p>
<p>TIME LIMIT: 2 seconds</p>
<h3 id="题意翻译">题意翻译</h3>
<p>约翰一共有N)个牧场.由M条布满尘埃的小径连接.小径可 以双向通行.每天早上约翰从牧场1出发到牧场N去给奶牛检查身体.</p>
<p>通过每条小径都需要消耗一定的时间.约翰打算升级其中K条小径，使之成为高 速公路.在高速公路上的通行几乎是瞬间完成的，所以高速公路的通行时间为0.</p>
<p>请帮助约翰决定对哪些小径进行升级，使他每天从1号牧场到第N号牧场所花的时间最短</p>
<h3 id="solve">Solve</h3>
<p>枚举每个边设零，然后跑最短路？k=1可能还可以，但是k&lt;=20，直接毙命。<br>
分层图于是闪亮登场。其实这道题还可以用动态规划做，但是在这里我们只讨论分层图（<s>其实是蒟蒻不会啦</s>）<br>
升级k条路径，就分k+1层图。第一层就是原图，每一层图内的点和边权都跟原图一样。但是层与层之间的边的边权为零。上层的u点连向下层的v点，边权为零，就相当于升级了这条小径，经过k层跑最短路到达n点，就相当于经过了已经升级了k条边的最短路。<br>
不一定要升级k条边，所以取每层图的最小代价。</p>
<h4 id="建图">建图</h4>
<pre><code class="language-cpp">for(int i=1;i&lt;=m;i++){
	scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
	add(u,v,w);add(v,u,w);
	for(int j=1;j&lt;=k;j++){
		add(u+j*n,v+j*n,w);
		add(v+j*n,u+j*n,w);
		add(u+(j-1)*n,v+j*n,0);
		add(v+(j-1)*n,u+j*n,0);//当然无向图需要双向
	}
}
</code></pre>
<p><strong>tip:分层图重要的是构造图的方法,最短路的话，随便啦。但是还是说一句“SPFA死了”</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define N 10000000
using namespace std;
int n,m,k,ans;
int u,v,w;
int dis[N];
int head[N],len;
struct note{
	int to,vl,nxt;
}eg[N];
struct node{
	int u,vl;
	bool operator&lt;(const node &amp;a)const{
		return a.vl&lt;vl;
	}
};
priority_queue&lt;node&gt; q;
bool vis[N];
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].vl=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
void dj(){
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	q.push((node){1,0});
	while(!q.empty()){
		int e=q.top().u;
		q.pop();
		if(vis[e]) continue;
		vis[e]=true;
		for(int i=head[e];i;i=eg[i].nxt){
			int v=eg[i].to;
			if(dis[v]&gt;dis[e]+eg[i].vl){
				dis[v]=dis[e]+eg[i].vl;
				if(!vis[v]) q.push((node){v,dis[v]});
			}
		}
	}
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);add(v,u,w);
		for(int j=1;j&lt;=k;j++){
			add(u+j*n,v+j*n,w);
			add(v+j*n,u+j*n,w);
			add(u+(j-1)*n,v+j*n,0);
			add(v+(j-1)*n,u+j*n,0);
		}
	}
	dj();
	ans=dis[n];
	for(int i=1;i&lt;=k;i++) ans=min(ans,dis[n+i*n]);
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h2 id="后言">后言</h2>
<p>这个方法真的很适合图中优化几次边权然后求最小代价的题。</p>
<h2 id="画外音">画外音</h2>
<p>数据过大的话，分层图可能就GG了。而这个时候就该用其他的方法惹。</p>
<h2 id="相关题目">相关题目</h2>
<p><a href="https://www.luogu.org/problem/P4822">P4822 [BJWC2012]冻结</a><br>
<a href="https://www.luogu.org/problem/P4568">P4568 [JLOI2011]飞行路线</a></p>
<h2 id="关于">关于</h2>
<p>[例图取自]（https://www.luogu.org/blog/xiaohou/fen-ceng-tu）<br>
封面不是啦。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3870 [TJOI2009]开关]]></title>
        <id>https://Kite-chaser.github.io/post/p3870-tjoi2009kai-guan</id>
        <link href="https://Kite-chaser.github.io/post/p3870-tjoi2009kai-guan">
        </link>
        <updated>2019-10-07T08:08:35.000Z</updated>
        <summary type="html"><![CDATA[<p>分块是一种优雅的暴力。</p>
]]></summary>
        <content type="html"><![CDATA[<p>分块是一种优雅的暴力。</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>现有N（2 ≤ N ≤ 100000）盏灯排成一排，从左到右依次编号为：1，2，......，N。然后依次执行M（1 ≤ M ≤ 100000）项操作，操作分为两种：第一种操作指定一个区间[a, b]，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开），第二种操作是指定一个区间[a, b]，要求你输出这个区间内有多少盏灯是打开的。灯在初始时都是关着的。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3870">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<ol>
<li>将n盏灯的状态分块。1表示开着，0表示关着。</li>
<li>tg[]表示每个块的修改状态。</li>
<li>通过“^”操作快速修改。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#define N 100001
using namespace std;
int n,m;
int t;
int ans;
int cnt,x,y;
struct note{
	int l,r,sum;
}d[N];
int num[N],tg[N];
int ln[N];
void ch(int l,int r){
	if(ln[l]==ln[r]){
		for(int i=l;i&lt;=r;i++){
			d[ln[i]].sum-=(num[i]^tg[ln[i]]);
			num[i]=1-num[i];
			d[ln[i]].sum+=(num[i]^tg[ln[i]]);
		}
	}
	else{
		for(int i=l;i&lt;=d[ln[l]].r;i++){
			d[ln[i]].sum-=(num[i]^tg[ln[i]]);
			num[i]=1-num[i];
			d[ln[i]].sum+=(num[i]^tg[ln[i]]);
		}
		for(int i=d[ln[r]].l;i&lt;=r;i++){
			d[ln[i]].sum-=(num[i]^tg[ln[i]]);
			num[i]=1-num[i];
			d[ln[i]].sum+=(num[i]^tg[ln[i]]);
		}
		for(int i=ln[l]+1;i&lt;=ln[r]-1;i++){
			tg[i]=1-tg[i];
			d[i].sum=(d[i].r-d[i].l+1)-d[i].sum;
		}
	}
}
int qu(int l,int r){
	if(ln[l]==ln[r]){
		for(int i=l;i&lt;=r;i++) ans+=(num[i]^tg[ln[i]]);
		return ans;
	}
	else{
		for(int i=l;i&lt;=d[ln[l]].r;i++) ans+=(num[i]^tg[ln[l]]);
		for(int i=d[ln[r]].l;i&lt;=r;i++) ans+=(num[i]^tg[ln[r]]);
		for(int i=ln[l]+1;i&lt;=ln[r]-1;i++){
			ans+=d[i].sum;
		}
		return ans;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	t=sqrt(n);
	for(int i=1;i&lt;=t;i++){
		d[i].l=(i-1)*t+1;
		d[i].r=i*t;
	}
	if(d[t].r&lt;n){
		t++;
		d[t].l=d[t-1].r+1;
		d[t].r=n;
	}
	int s=1;
	for(int i=1;i&lt;=n;i++){
		if(d[s].r&lt;i) s++;
		ln[i]=s;
	}
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;cnt,&amp;x,&amp;y);
		if(cnt){
			ans=0;
			printf(&quot;%d\n&quot;,qu(x,y));
		}
		else ch(x,y);
	}
	return 0; 
}
</code></pre>
<h2 id="关于分块">关于分块</h2>
<p>没有学过分块的朋友可以康康hzw大神的<a href="http://hzwer.com/8053.html">分块九讲</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2986 [USACO10MAR]伟大的奶牛聚集Great Cow Gat…]]></title>
        <id>https://Kite-chaser.github.io/post/p2986-usaco10marwei-da-de-nai-niu-ju-ji-great-cow-gat</id>
        <link href="https://Kite-chaser.github.io/post/p2986-usaco10marwei-da-de-nai-niu-ju-ji-great-cow-gat">
        </link>
        <updated>2019-10-03T10:08:28.000Z</updated>
        <summary type="html"><![CDATA[<p>话说描述下面一大坨是什么东西……</p>
]]></summary>
        <content type="html"><![CDATA[<p>话说描述下面一大坨是什么东西……</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>Bessie is planning the annual Great Cow Gathering for cows all across the country and, of course, she would like to choose the most convenient location for the gathering to take place.</p>
<p>Bessie正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。</p>
<p>Each cow lives in one of N (1 &lt;= N &lt;= 100,000) different barns (conveniently numbered 1..N) which are connected by N-1 roads in such a way that it is possible to get from any barn to any other barn via the roads. Road i connects barns A_i and B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N) and has length L_i (1 &lt;= L_i &lt;= 1,000). The Great Cow Gathering can be held at any one of these N barns. Moreover, barn i has C_i (0 &lt;= C_i &lt;= 1,000) cows living in it.</p>
<p>每个奶牛居住在 N(1&lt;=N&lt;=100,000) 个农场中的一个，这些农场由N-1条道路连接，并且从任意一个农场都能够到达另外一个农场。道路i连接农场A_i和B_i(1 &lt;= A_i &lt;=N; 1 &lt;= B_i &lt;= N),长度为L_i(1 &lt;= L_i &lt;= 1,000)。集会可以在N个农场中的任意一个举行。另外，每个牛棚中居住者C_i(0 &lt;= C_i &lt;= 1,000)只奶牛。</p>
<p>When choosing the barn in which to hold the Cow Gathering, Bessie wishes to maximize the convenience (which is to say minimize the inconvenience) of the chosen location. The inconvenience of choosing barn X for the gathering is the sum of the distances all of the cows need to travel to reach barn X (i.e., if the distance from barn i to barn X is 20, then the travel distance is C_i*20). Help Bessie choose the most convenient location for the Great Cow Gathering.</p>
<p>在选择集会的地点的时候，Bessie希望最大化方便的程度(也就是最小化不方便程度)。比如选择第X个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和，(比如，农场i到达农场X的距离是20，那么总路程就是C_i*20)。帮助Bessie找出最方便的地点来举行大集会。</p>
<p>Consider a country with five barns with [various capacities] connected by various roads of varying lengths. In this set of barns, neither barn 3 nor barn 4 houses any cows.</p>
<p>1 3 4 5</p>
<p>@--1--@--3--@--3--@[2]</p>
<p>[1] |</p>
<p>2 | @[1] 2 Bessie can hold the Gathering in any of five barns; here is the table of inconveniences calculated for each possible location:</p>
<p>Gather ----- Inconvenience ------</p>
<p>Location B1 B2 B3 B4 B5 Total</p>
<p>1 0 3 0 0 14 17</p>
<p>2 3 0 0 0 16 19</p>
<p>3 1 2 0 0 12 15</p>
<p>4 4 5 0 0 6 15</p>
<p>5 7 8 0 0 0 15</p>
<p>If Bessie holds the gathering in barn 1, then the inconveniences from each barn are:</p>
<p>Barn 1 0 -- no travel time there!</p>
<p>Barn 2 3 -- total travel distance is 2+1=3 x 1 cow = 3 Barn 3 0 -- no cows there!</p>
<p>Barn 4 0 -- no cows there!</p>
<p>Barn 5 14 -- total travel distance is 3+3+1=7 x 2 cows = 14 So the total inconvenience is 17.</p>
<p>The best possible convenience is 15, achievable at by holding the Gathering at barns 3, 4, or 5.</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2986">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<p>简单点说就是用树的重心求解。<br>
类似于这种树上到一点然后求最小价值的题大多是树的重心。<br>
也就是所求的这一点。<br>
有关树的重心，见蒟蒻的<a href="https://kite-chaser.github.io/post/shu-de-chong-xin/">笔记</a>。<br>
然后从树的重心，求到各点的路径长度和代价即可。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
#define N 100001
using namespace std;
ll n;
ll maxn=1000000000000000000,ans;
ll cnt,sum;
ll c[N];
ll x,y,z;
ll dis[N],d[N];  //dis-从树的重心到节点的路径长度
ll first[N*2],nxt[N*2],to[N*2],w[N*2],len;
void add(ll u,ll v,ll z){
	to[++len]=v;
	w[len]=z;
	nxt[len]=first[u];
	first[u]=len;
}
void dp(ll s,ll fa){
	d[s]=c[s];
	ll res=0;
	for(ll i=first[s];i!=-1;i=nxt[i]){
		if(to[i]==fa) continue;
		dp(to[i],s);
		d[s]+=d[to[i]];
		res=max(res,d[to[i]]);
	}
	res=max(res,sum-d[s]);
	if(res&lt;maxn){
		maxn=res;
		cnt=s;
	}
}
void dfs(ll s,ll fa){
	for(ll i=first[s];i!=-1;i=nxt[i]){
		if(to[i]==fa) continue;
		dis[to[i]]=dis[s]+w[i];
		dfs(to[i],s);
	}
}
int main()
{
	memset(first,-1,sizeof(first));
	scanf(&quot;%lld&quot;,&amp;n);
	for(ll i=1;i&lt;=n;i++){
		scanf(&quot;%lld&quot;,&amp;c[i]);sum+=c[i];
	}
	for(ll i=1;i&lt;n;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);
		add(x,y,z);
		add(y,x,z);
	}
	dp(1,1);
	dis[cnt]=0;
	dfs(cnt,cnt);
	for(ll i=1;i&lt;=n;i++){
		ans+=dis[i]*c[i];
	}
	printf(&quot;%lld&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1270 “访问”美术馆]]></title>
        <id>https://Kite-chaser.github.io/post/p1270-fang-wen-mei-zhu-guan</id>
        <link href="https://Kite-chaser.github.io/post/p1270-fang-wen-mei-zhu-guan">
        </link>
        <updated>2019-09-21T09:45:36.000Z</updated>
        <summary type="html"><![CDATA[<p>我肝了好久……</p>
]]></summary>
        <content type="html"><![CDATA[<p>我肝了好久……</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要5秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。<br>
<img src="https://Kite-chaser.github.io/post-images/1569059240907.png" alt=""><br>
样例的图……</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1270">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<p>树形DP-树形背包<br>
mon[i]到节点i的用时<br>
<s>十年DP推方程</s></p>
<ol>
<li>设计状态：d[i][j]，以i为根节点，取画j副时的最少用时。</li>
<li>边界：d[i][j]=j*5,(i为展室，0&lt;=j&lt;=该展室画数）</li>
<li>转移方程：d[u][j]=min(d[u][j],d[u][j-k]+d[v][k]+mon[v]).（u到v有边；j为u的最大画数）</li>
<li>按照最大画幅，倒序枚举，用时低于S的就是答案。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 1010
using namespace std;
int s;
int tree[N*10];
int mon[N],vl[N],cnt;
int d[N][N];
int sz[N],sum;
int first[N],nxt[N],to[N],len;
void add(int u,int v){
	to[++len]=v;
	nxt[len]=first[u];
	first[u]=len;
}
void infs(int u){
	mon[u]=mon[u]*2;
	if(vl[u]){
		sum+=vl[u];
		for(int i=0;i&lt;=vl[u];i++) d[u][i]=i*5;
		return ;
	}
	scanf(&quot;%d%d&quot;,&amp;mon[u*2],&amp;vl[u*2]);
	add(u,u*2);infs(u*2);
	scanf(&quot;%d%d&quot;,&amp;mon[u*2+1],&amp;vl[u*2+1]);
	add(u,u*2+1),infs(u*2+1);
}
void dfs(int u){
	if(vl[u]){
		sz[u]=vl[u];
		return ;
	}
	for(int i=first[u];i!=-1;i=nxt[i]){
		dfs(to[i]);
		sz[u]+=sz[to[i]];
		for(int j=sz[u];j&gt;=0;j--){
			for(int k=min(j,sz[to[i]]);k&gt;=0;k--) d[u][j]=min(d[u][j],d[u][j-k]+d[to[i]][k]+mon[to[i]]);
		}
	}
}
int main()
{
	memset(first,-1,sizeof(first));
	for(int i=0;i&lt;=1001;i++) for(int j=1;j&lt;=1001;j++) d[i][j]=30000;
	scanf(&quot;%d&quot;,&amp;s);
	s--;
	add(0,1);
	scanf(&quot;%d%d&quot;,&amp;mon[1],&amp;vl[1]);
	infs(1);
	dfs(0);
	for(int i=sum;i&gt;=0;i--){
		if(d[0][i]&lt;s){
			printf(&quot;%d&quot;,i);
			return 0;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1314 聪明的质监员]]></title>
        <id>https://Kite-chaser.github.io/post/p1314-cong-ming-de-zhi-jian-yuan</id>
        <link href="https://Kite-chaser.github.io/post/p1314-cong-ming-de-zhi-jian-yuan">
        </link>
        <updated>2019-09-14T07:17:15.000Z</updated>
        <summary type="html"><![CDATA[<p>我感受到了memset的力量。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我感受到了memset的力量。</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>小T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有n个矿石，从1到n 逐一编号，每个矿石都有自己的重量 w_i 以及价值v_i。检验矿产的流程是：</p>
<ol>
<li>给定m个区间[L_i,R_i]；</li>
<li>选出一个参数W；</li>
<li>对于一个区间[L_i,R_i]，计算矿石在这个区间上的检验值Y_i：<br>
<img src="https://Kite-chaser.github.io/post-images/1568450521669.png" alt=""><br>
这批矿产的检验结果Y为各个区间的检验值之和。即：Y_1+Y_2...+Y_m<br>
若这批矿产的检验结果与所给标准值S相差太多，就需要再去检验另一批矿产。小T不想费时间去检验另一批矿产，所以他想通过调整参数W 的值，让检验结果尽可能的靠近标准值S，即使得S-Y的绝对值最小。请你帮忙求出这个最小值。</li>
</ol>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1314">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<h3 id="一-二分">一 二分</h3>
<p>在每个区间内，只有w[]大于W的，才能被选上。<br>
所以W减小，被选入的矿石增多，Y增加；反之Y减小。<br>
条件：</p>
<ul>
<li>Y&gt;S,增大W，减小Y，以使|Y-S|减小。</li>
<li>Y&lt;S,减小W，增大Y，以使|Y-S|减小。</li>
<li>Y=S，完美。</li>
</ul>
<h3 id="二-前缀和">二 前缀和</h3>
<p>使用前缀和以减少区间修改的时间。</p>
<ul>
<li>w[]&gt;=W,sum1[i]=sum1[i-1]+1,sum2[i]=sum2[i-1]+v[i],sum1表示公式中前者，sum2表示后者。</li>
<li>w[]&lt;W,sum1[i]=sum1[i-1],sum2[i]=sum2[i-1]。</li>
</ul>
<h2 id="tip">Tip</h2>
<ol>
<li>答案初始值一定要设的非常大。</li>
<li>不开longlong见祖宗。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define N 200010
#define ll long long
using namespace std;
ll n,m,k;
ll W;
ll ans=999999999999999999,num;
ll l=1,r,mid;
ll s[N],t[N];
ll sum1[N],sum2[N];
ll w[N],v[N];
bool sl(ll cnt){
	ll num=0;
	memset(sum1,0,sizeof(sum1));
	memset(sum2,0,sizeof(sum2));
	for(ll i=1;i&lt;=n;i++){
		if(w[i]&gt;=cnt) sum1[i]=sum1[i-1]+1,sum2[i]=sum2[i-1]+v[i];
		else sum1[i]=sum1[i-1],sum2[i]=sum2[i-1];
	}
	for(ll i=1;i&lt;=m;i++){
		num+=(sum1[t[i]]-sum1[s[i]-1])*(sum2[t[i]]-sum2[s[i]-1]);
	}
	if(num&gt;k){
		ans=min(ans,num-k);
		return false;
	}
	ans=min(ans,k-num);
	return true;
}
int main()
{
	scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);
	for(ll i=1;i&lt;=n;i++) scanf(&quot;%lld%lld&quot;,&amp;w[i],&amp;v[i]),r=max(r,w[i]);
	for(ll i=1;i&lt;=m;i++) scanf(&quot;%lld%lld&quot;,&amp;s[i],&amp;t[i]);
	r+=2;
	while(l&lt;r){
		mid=(l+r)/2;
		if(sl(mid)) r=mid;
		else l=mid+1;
	}
	printf(&quot;%lld&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1083 借教室]]></title>
        <id>https://Kite-chaser.github.io/post/p1083-jie-jiao-shi</id>
        <link href="https://Kite-chaser.github.io/post/p1083-jie-jiao-shi">
        </link>
        <updated>2019-09-14T03:34:21.000Z</updated>
        <summary type="html"><![CDATA[<p>二分答案是真的妙。</p>
]]></summary>
        <content type="html"><![CDATA[<p>二分答案是真的妙。</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。<br>
面对海量租借教室的信息，我们自然希望编程解决这个问题。<br>
我们需要处理接下来n天的借教室信息，其中第i天学校有r_i个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为d_j,s_j,t_j表示某租借者需要从第s_j天到第t_j天租借教室（包括第s_j天和第t_j天），每天需要租借d_j个教室。<br>
我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供d_j个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p>
<p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第s_j 天到第t_j天中有至少一天剩余的教室数量不足d_j个。</p>
<p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1083">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<p>简简单单的二分。<br>
二分天数。<br>
可以的话取右区间。<br>
不可以的话取左区间。<br>
对于区间修改，使用差分就好啦。</p>
<h2 id="tip">Tip</h2>
<ol>
<li>二分是真的快，log的。</li>
<li>差分是真的快，O(1)的。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 1000001
using namespace std;  //标准开头
int n,m;
int a[N],f[N];
int d[N],s[N],t[N];
int res[N];
int l,r,mid;
bool sl(int x){
	for(int i=1;i&lt;=n;i++) f[i]=a[i]-a[i-1],res[i]=a[i];   //差分
	for(int i=1;i&lt;=x;i++){
		f[s[i]]-=d[i];
		f[t[i]+1]+=d[i];
	}
	for(int i=1;i&lt;=n;i++){
		res[i]=f[i]+res[i-1];
		if(res[i]&lt;0) return false;
	}
	return true;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;d[i],&amp;s[i],&amp;t[i]);
	l=1;r=m;
	if(sl(m)){printf(&quot;0&quot;);return 0;}
	while(l&lt;r){
		mid=(l+r)/2;
		if(sl(mid)) l=mid+1;
		else r=mid;
	}
	printf(&quot;-1\n%d&quot;,l);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2014 选课]]></title>
        <id>https://Kite-chaser.github.io/post/p2014-xuan-ke</id>
        <link href="https://Kite-chaser.github.io/post/p2014-xuan-ke">
        </link>
        <updated>2019-09-14T02:59:29.000Z</updated>
        <summary type="html"><![CDATA[<p>这道题使我对树形DP有了新认识。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这道题使我对树形DP有了新认识。</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2014">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<p>每门课有一门或没有直接先修课，说明所有课程节点构成的图一定是树。<br>
所以树形DP莽就完了。</p>
<p>d[i][j]表示以i为根节点的子树包含j个节点（不含根节点）时最大价值。<br>
sz[i]表示以i为根节点的子树的节点数。<br>
u为父节点，v为u的子节点。<br>
对于以i为根节点的子树，d值来自两部分，一棵子树的值（d[v][k]）和其他子树的值(d[u][j-k-1])的和。因为j里面实际不包含节点v，所以再-1。<br>
则转移方程为d[u][j]=max(d[u][j],d[u][j-k-1]+d[v][k]+s[v])，j&lt;=sz[i],k&lt;=sz[v]。</p>
<h2 id="tip">Tip</h2>
<ol>
<li>没有直接先修课的，建立节点0为虚根，作为他们的父节点。</li>
<li>这是树形背包。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 400
using namespace std;
int n,m;
int k[N],s[N];
int d[N][N];
int sz[N];
int first[N],nxt[N],to[N],len;
void add(int u,int v){
   to[++len]=v;
   nxt[len]=first[u];
   first[u]=len;
}
void dfs(int u){
   sz[u]=1;
   for(int i=first[u];i!=-1;i=nxt[i]){
   	dfs(to[i]);
   	sz[u]+=sz[to[i]];
   	for(int j=min(m,sz[u]);j&gt;=0;j--){
   		for(int k=min(j-1,sz[to[i]]);k&gt;=0;k--) d[u][j]=max(d[u][j],d[u][j-k-1]+d[to[i]][k]+s[to[i]]);
   	}
   }
}
int main()
{
   memset(first,-1,sizeof(first));
   scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
   for(int i=1;i&lt;=n;i++){
   	scanf(&quot;%d%d&quot;,&amp;k[i],&amp;s[i]);
   	add(k[i],i);
   }
   dfs(0);
   printf(&quot;%d&quot;,d[0][m]);
   return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[整除]]></title>
        <id>https://Kite-chaser.github.io/post/zheng-chu</id>
        <link href="https://Kite-chaser.github.io/post/zheng-chu">
        </link>
        <updated>2019-09-14T00:25:49.000Z</updated>
        <summary type="html"><![CDATA[<p>只是一点关于整除的性质而已。</p>
]]></summary>
        <content type="html"><![CDATA[<p>只是一点关于整除的性质而已。</p>
<!--more-->
<p>设a是非零整数，b是整数。如果存在一个整数q，使得b=a*q，那么就说b可被a整除，记作a|吧，且称b是a的倍数，a是b的约数（因子）。<br>
例如3|12，21|63。整除具有以下性质：</p>
<ol>
<li>如果a|b且b|c，那么a|c。</li>
<li>a|b且a|c等价于对任意的整数x和y，有a|（b<em>x+c</em>y）。</li>
<li>设m≠0，那么a|b等价于（m<em>a）|（m</em>b）。</li>
<li>设整数x和y满足下式：a<em>x+b</em>y=1，且a|n、b|n，那么（a<em>b）|n。<br>
证明：因为a|n且b|n<br>
据性质3得：（a</em>b）|（b<em>n）且（a</em>b）|（a<em>n）<br>
据性质2得：（a</em>b）|（a<em>n</em>x+b<em>n</em>y）<br>
其中：a<em>n</em>x+b<em>n</em>y=n*（a<em>x+b</em>y）=n<em>1=n<br>
所以（a</em>b）|n</li>
<li>若b=q*d+c，那么d|b得充要条件是d|c。</li>
</ol>
]]></content>
    </entry>
</feed>