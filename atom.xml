<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Kite-chaser.github.io</id>
    <title>Kite-chaser</title>
    <updated>2019-11-11T06:54:26.433Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Kite-chaser.github.io"/>
    <link rel="self" href="https://Kite-chaser.github.io/atom.xml"/>
    <subtitle>This is my blog.</subtitle>
    <logo>https://Kite-chaser.github.io/images/avatar.png</logo>
    <icon>https://Kite-chaser.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Kite-chaser</rights>
    <entry>
        <title type="html"><![CDATA[P5022 旅行]]></title>
        <id>https://Kite-chaser.github.io/post/p5022-lu-xing</id>
        <link href="https://Kite-chaser.github.io/post/p5022-lu-xing">
        </link>
        <updated>2019-11-11T03:43:22.000Z</updated>
        <summary type="html"><![CDATA[<p>口胡系列……</p>
]]></summary>
        <content type="html"><![CDATA[<p>口胡系列……</p>
<!--more-->
<h3 id="题目描述">题目描述</h3>
<p>小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。</p>
<p>小Y了解到， X国的 <em>n</em> 个城市之间有 <em>m</em> 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。</p>
<p>小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。</p>
<p>为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 <em>n</em> 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？ 对于两个长度均为 <em>n</em> 的序列 <em>A</em> 和 <em>B</em>，当且仅当存在一个正整数 <em>x</em>，满足以下条件时， 我们说序列 <em>A</em> 的字典序小于 <em>B</em>。</p>
<ul>
<li>对于任意正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1&lt;i&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，序列 <em>A</em> 的第 <em>i</em> 个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和序列 <em>B</em> 的第 <em>i</em> 个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">B_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>相同。</li>
<li>序列 <em>A</em> 的第 <em>x</em> 个元素的值小于序列 <em>B</em> 的第 <em>x</em> 个元素的值。</li>
</ul>
<blockquote>
<p>[戳]（ https://www.luogu.org/problem/P5022 ）</p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>题意看似复杂，其实很显然。</p>
<p>首先让我们面向数据编程。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/a6hb562a.png" alt=""></figure>
<h4 id="mn-1">m=n-1</h4>
<p>当m=n-1时，图也就变成了一棵树</p>
<p>也就是这个亚子的。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/31njzxcr.png" alt=""></figure>
<p>（滑稽</p>
<p>那么小Y所要求的旅行方案就是这棵树字典序最小的DFS序。</p>
<p>字典序最小是题目要求的，不解释，那为什么是DFS呢？</p>
<p><strong>每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市</strong></p>
<p>你难道不觉得这很像DFS的遍历方式吗。</p>
<p>当你已经确定一个节点为下一个遍历目标的时候，你就一定要遍历完他的子树，否则一旦回溯，就再也回不来了。</p>
<p>反过来，DFS序就不用多解释了。如何遍历才能做到字典序最小呢？首先肯定要从节点1开始，否则直接输在起跑线上。然后呢？按照节点编号从小到大直接遍历就珂以了。</p>
<p>进一步说，如何保证从小到大的遍历顺序呢？如果你用邻接矩阵的话，请随意。如果是邻接表的话，排个序就行了。真的。</p>
<p>首先保证边（u，v）中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>&lt;</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u&lt;v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。</p>
<p>以u为第一关键字，v为第二关键字。从大到小排序。因为剖析邻接表的本质，存的边，相对于存进来时的边，他是倒序的。这样就保证了按照邻接表遍历的时候，是从小到大遍历的。</p>
<p>这也是我做这道题时，口胡的一种做法，应该对。</p>
<p>然后，我们可以那到60分的好成绩，<s>然而加上D1T1T2还是够不上SD的分数线</s></p>
<h4 id="mn">m=n</h4>
<p>当m=n时。</p>
<p>猜猜这叫什么，还是树。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/31njzxcr.png" alt=""></figure>
<p>（滑稽</p>
<p>但是他换了个名字，叫基环树，其实也就是树上多了个环。因为m=n。那该怎么做呢？我们之前有了树上的做法，所以我们可以把他变成树来做。一条边的事。</p>
<p>找环然后挨个删边，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>暴力。</p>
<p>找环的话就自己想想叭，挺简单的。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define N 500001
using namespace std;
int n,m,ans[N],res[N],txt,num1,num2;
int head[N],len;
int st[N],cnt;
bool vis[N],fis[N];
struct node{
	int to,nxt,r;
}eg[N*2];
struct note{
	int u,v;
}d[N*2];
bool cmp(const note a,const note b){
	if(a.u!=b.u) return a.u&gt;b.u;
	else return a.v&gt;b.v;
}
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].r=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
void find_ring(int u,int fa){//vis是否在环里，fis是否遍历过，eg[].r为边的编号
	fis[u]=true;
	for(int i=head[u];i;i=eg[i].nxt){
		int v=eg[i].to;
		if(eg[i].r!=fa&amp;&amp;fis[v]&amp;&amp;txt==0){
			vis[u]=true;
			txt=v;
		}
		else if(eg[i].r!=fa&amp;&amp;!fis[v]){
			find_ring(v,eg[i].r);
			if(vis[v]) vis[u]=true;
		}
	}
	if(vis[u]) st[++cnt]=u;
	if(u==txt) vis[u]=false;
} 
void dfs(int u,int fa){
	res[++txt]=u;
	for(int i=head[u];i;i=eg[i].nxt){
		int v=eg[i].to;
		if((u==num1&amp;&amp;v==num2)||(v==num1&amp;&amp;u==num2)) continue;
		if(v==fa) continue;
		dfs(v,u);
	}
}
void new_ans()
{
	if(ans[1]==0){
		for(int i=1;i&lt;=n;i++) ans[i]=res[i];
		return ;
	}
	for(int i=1;i&lt;=n;i++){
		if(res[i]&gt;ans[i]) break;
		if(res[i]&lt;ans[i]){
			for(int j=i;j&lt;=n;j++) ans[j]=res[j];
			return ;
		}
	}
	return ;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++) {
		scanf(&quot;%d%d&quot;,&amp;d[i].u,&amp;d[i].v);
		if(d[i].u&gt;d[i].v) swap(d[i].u,d[i].v);
	}
	sort(d+1,d+1+m,cmp);
	for(int i=1;i&lt;=m;i++) add(d[i].u,d[i].v,i),add(d[i].v,d[i].u,i); 
	if(m==n-1){
		dfs(1,1);
		for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,res[i]);
	}
	else{
		find_ring(1,-1);
		for(int i=1;i&lt;=cnt;i++){
			txt=0;
			if(i==cnt) num1=st[cnt],num2=st[1];
			else num1=st[i],num2=st[i+1];
			dfs(1,1);
			new_ans(); 
		}
		for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,ans[i]);
	}
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>这个找环也是我之前做一道基环树题时口胡的做法。所以这篇题解珂以说是口胡系列。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1272 重建道路]]></title>
        <id>https://Kite-chaser.github.io/post/p1272-chong-jian-dao-lu</id>
        <link href="https://Kite-chaser.github.io/post/p1272-chong-jian-dao-lu">
        </link>
        <updated>2019-11-10T09:30:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>一场可怕的地震后，人们用N个牲口棚(1≤N≤150，编号1..N)重建了农夫John的牧场。由于人们没有时间建设多余的道路，所以现在从一个牲口棚到另一个牲口棚的道路是惟一的。因此，牧场运输系统可以被构建成一棵树。John想要知道另一次地震会造成多严重的破坏。有些道路一旦被毁坏，就会使一棵含有P(1≤P≤N)个牲口棚的子树和剩余的牲口棚分离，John想知道这些道路的最小数目。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1272">戳</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>树形DP……<br>
首先让我们设计一下状态。<br>
那就直接点，设f[u][j]为以u为根节点的子树，保留j个节点（包括ta本身），所用最小的道路数。<br>
<strong>初始</strong>：所有的状态都赋个极大值，然后赋f[u][1]都为子节点数目，因为ta要只剩下自己。<br>
<strong>目标</strong>：min（f[root][p],f[u][p]+1(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>!</mo><mo>=</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">p!=root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>) ) root为整棵树的根节点。<br>
+1是因为要从u的父节点除去到u的边。<br>
<strong>转移方程</strong>：f[u][j]=min(f[u][j],f[u][j-k]+f[v][k]-1),用v来更新u，所以需要保留u到v这条边，所以+1</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 1000
using namespace std;
int n,p,root,ans=10000000;
int f[N][N],du[N],cnt[N];
int head[N],len,to[N],nxt[N];
int u,v;
bool vis[N];
void add(int u,int v){
	to[++len]=v;
	nxt[len]=head[u];
	head[u]=len;
}
void dfs(int u){
	cnt[u]=1;
	f[u][1]=min(f[u][1],du[u]);
	for(int i=head[u];i;i=nxt[i]){
		int v=to[i];
		dfs(v);
		cnt[u]+=cnt[v];
		for(int j=cnt[u];j&gt;=1;j--){
			for(int k=1;k&lt;j;k++) f[u][j]=min(f[u][j],f[u][j-k]+f[v][k]-1);
		}
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;p);
	for(int i=1;i&lt;n;i++){
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		add(u,v);
		du[u]++;vis[v]=true;
	}
	memset(f,0x3f,sizeof(f));
	for(int i=1;i&lt;=n;i++){
		if(!vis[i]){
			root=i;
			break;
		}
	}
	dfs(root);
	ans=f[root][p];
	for(int i=1;i&lt;=n;i++) ans=min(ans,f[i][p]+1);
	printf(&quot;%d&quot;,ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3948 数据结构]]></title>
        <id>https://Kite-chaser.github.io/post/p3948-shu-ju-jie-gou</id>
        <link href="https://Kite-chaser.github.io/post/p3948-shu-ju-jie-gou">
        </link>
        <updated>2019-11-07T13:34:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>蒟蒻Edt把这个问题交给了你 ———— 一个精通数据结构的大犇，由于是第一题，这个题没那么难。。</p>
<p>edt 现在对于题目进行了如下的简化：</p>
<p>最开始的数组每个元素都是0</p>
<p>给出n，opt，mod，min，max，mod在int范围内</p>
<p>操作A，Q</p>
<p>A: L,R,X 表示把[l,R]这个区间加上X</p>
<p>（数组的从L到R的每个元素都加上X）</p>
<p>Q: L,R表示询问[L,R]这个区间中元素T满足 min&lt;=(T∗i%mod)&lt;=max的 T这样的数的个数（i是数组下标）</p>
<p>（元素的值*数组下标%mod在min到max范围内）</p>
<p>由于 edt 请来了一位非三次元的仓鼠，他帮你用延后了部分问题，将这些询问打入了混乱时空，你的询问操作不会超过1000次，不幸的是，对于延后的询问操作可能有很多次（小于1e7次），但是保证这些延后的询问操作之后不会再次有修改操作</p>
<p>（就是在最后会有很多次询问，但不会进行修改）</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3948">戳</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>有点混乱，其实有用的话就这两句。<br>
<strong>（数组的从L到R的每个元素都加上X）</strong>，<strong>（元素的值*数组下标%mod在min到max范围内）</strong><br>
差分处理，对于前面的询问暴力处理。<br>
而后面的询问用前缀和优化。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 80001
#define ll long long
using namespace std;
ll n,opt,mod,mint,maxt,final;
ll l,r,w;
ll a[N],sum[N];
int main()
{
	scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;n,&amp;opt,&amp;mod,&amp;mint,&amp;maxt);
	for(ll i=1;i&lt;=opt;i++){
		char c;
		cin&gt;&gt;c;
		if(c=='A'){
			scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;w);
			a[l]+=w;
			a[r+1]-=w;
		}
		else{
			scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);
			ll now=0,ans=0;
			for(ll j=1;j&lt;=r;j++){
				now+=a[j];
				if(j&gt;=l){
					if((now*j)%mod&gt;=mint&amp;&amp;(now*j)%mod&lt;=maxt) ans++;
				}
			}
			printf(&quot;%lld\n&quot;,ans);
		}
	}
	for(ll i=1;i&lt;=n;i++){
		a[i]+=a[i-1];
		sum[i]=sum[i-1];
		if((a[i]*i)%mod&gt;=mint&amp;&amp;(a[i]*i)%mod&lt;=maxt) sum[i]++;
	}
	scanf(&quot;%lld&quot;,&amp;final);
	for(ll i=1;i&lt;=final;i++){
		scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r);
		printf(&quot;%lld\n&quot;,sum[r]-sum[l-1]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ P4231 三步必杀]]></title>
        <id>https://Kite-chaser.github.io/post/p4231-san-bu-bi-sha</id>
        <link href="https://Kite-chaser.github.io/post/p4231-san-bu-bi-sha">
        </link>
        <updated>2019-11-07T11:15:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p><em>N</em>个柱子排成一排，一开始每个柱子损伤度为0。</p>
<p>接下来勇仪会进行<em>M</em>次攻击，每次攻击可以用4个参数<em>l</em>,<em>r</em>,<em>s</em>,<em>e</em>来描述：</p>
<p>表示这次攻击作用范围为第<em>l</em>个到第<em>r</em>个之间所有的柱子(包含<em>l</em>,<em>r</em>)，对第一个柱子的伤害为<em>s</em>，对最后一个柱子的伤害为<em>e</em>。</p>
<p>攻击产生的伤害值是一个等差数列。若<em>l</em>=1,<em>r</em>=5,<em>s</em>=2,<em>e</em>=10，则对第1~5个柱子分别产生2,4,6,8,10的伤害。</p>
<p>鬼族们需要的是所有攻击完成之后每个柱子的损伤度。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P4231">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>如果是区间内都增加一个相同的数值的话，那这个题就很显然了，树状数组、线段树和差分数组都可以秒切，但是此题增加的是一个等差数列，那我们怎么做呢？</p>
<p><em>1</em>，暴力?每次询问都从l到r扫个遍？想想都不行。</p>
<p><em>2</em>，差分？树状数组？线段树？又好像跟我们认识的不太一样。</p>
<p>所以，就让我们打开新世界的大门，认识差分的另一面。</p>
<p>普通的差分数组：</p>
<table>
<thead>
<tr>
<th style="text-align:left">a(原数组)</th>
<th>1</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">b(差分数组)</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>而联系上等差序列呢？</p>
<table>
<thead>
<tr>
<th>a（等差序列）</th>
<th>2</th>
<th>4</th>
<th>6</th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>b(差分数组)</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>当然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不一定等于公差。看完了之后有什么想法吗？</p>
<p>如果我们在差分一次呢？我们叫他二阶差分。</p>
<table>
<thead>
<tr>
<th>a（等差序列）</th>
<th>2</th>
<th>4</th>
<th>6</th>
<th>8</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>b（差分数组）</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>c（二阶差分）</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>通化一点</p>
<table>
<thead>
<tr>
<th>a（原数组）</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>a(加上等差序列)</td>
<td>0</td>
<td>s</td>
<td>s+d</td>
<td>e(s+2d)</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>b（差分数组）</td>
<td>0</td>
<td>s</td>
<td>d</td>
<td>d</td>
<td>-e</td>
<td>0</td>
</tr>
<tr>
<td>c(二阶差分)</td>
<td>0</td>
<td>s</td>
<td>d-s</td>
<td>0</td>
<td>-e-d</td>
<td>e</td>
</tr>
</tbody>
</table>
<p><strong>s为首项，e为尾项，d为公差</strong></p>
<p><strong>a关于b差分，如同b关于c差分</strong></p>
<p>于是我们成功的将区间加转变为了单点加，复杂度呜呜地减。</p>
<p>最后一次还原就好啦。</p>
<h3 id="tip">Tip</h3>
<p>莫得忘了开long long</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 10000001
#define ll long long
using namespace std;
ll n,m;
ll l,r,s,e;
ll ans1,ans2;
ll a[N],b[N],c[N];
inline ll read(){
    ll x=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int main()
{
	n=read();m=read();
	for(ll i=1;i&lt;=m;i++){
		l=read();r=read();s=read();e=read();
		ll d=(e-s)/(r-l);
		c[l]+=s;
		c[l+1]+=(d-s);
		c[r+1]+=(-e-d);
		c[r+2]+=e;
	}
	for(ll i=1;i&lt;=n;i++){
		b[i]=c[i]+b[i-1];
		a[i]=b[i]+a[i-1];
		ans1^=a[i];
		ans2=max(ans2,a[i]);
	}
	printf(&quot;%lld %lld&quot;,ans1,ans2);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2055 [ZJOI2009]假期的宿舍]]></title>
        <id>https://Kite-chaser.github.io/post/p2055-zjoi2009jia-qi-de-su-she</id>
        <link href="https://Kite-chaser.github.io/post/p2055-zjoi2009jia-qi-de-su-she">
        </link>
        <updated>2019-11-02T03:08:18.000Z</updated>
        <summary type="html"><![CDATA[<p>二分图水题</p>
]]></summary>
        <content type="html"><![CDATA[<p>二分图水题</p>
<!--more-->
<h3 id="题目描述">题目描述</h3>
<p>学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。</p>
<p>比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。</p>
<p>我们已知一共有 n 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2055">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>首先，我们得知道二分图最大匹配和匈牙利算法。<br>
然后，就很简单了。<br>
建图，每个不回家在校学生可睡自己的床也可白嫖其他认识的在校学生的床，非在校学生可白嫖认识的在校学生的床。<br>
匈牙利算法。<br>
<strong>注意重置</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 1010
using namespace std;
int t;
int n;
int head[N*N],to[N*N],nxt[N*N],len;
int sis[N],mis[N],num,hb[N];
bool vis[N];
void add(int u,int v){
	to[++len]=v;
	nxt[len]=head[u];
	head[u]=len;
}
bool zm(int u){
	for(int i=head[u];i!=-1;i=nxt[i]){
		int v=to[i];
		if(vis[v]) continue;
		vis[v]=true;
		if(!hb[v]||zm(hb[v])){
			hb[v]=u;
			return true;
		}
	}
	return false;
}
bool check(int u){
	memset(vis,false,sizeof(vis));
	return zm(u);
}
int main()
{
	scanf(&quot;%d&quot;,&amp;t);
	while(t--){
		scanf(&quot;%d&quot;,&amp;n);
		len=0;
		bool flag=false;
		memset(head,-1,sizeof(head));
		memset(hb,0,sizeof(hb));		
		for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;sis[i]);
		for(int i=1;i&lt;=n;i++){
			scanf(&quot;%d&quot;,&amp;mis[i]);
			if(sis[i]&amp;&amp;!mis[i]) add(i,i+n);
		}
		for(int i=1;i&lt;=n;i++){
			for(int j=1;j&lt;=n;j++){
				scanf(&quot;%d&quot;,&amp;num);
				if(sis[i]==1&amp;&amp;mis[i]==1) continue;
				if(num==1&amp;&amp;sis[j]==1) add(i,j+n);
			}
		}
		for(int i=1;i&lt;=n;i++){
			if(sis[i]==1&amp;&amp;mis[i]==1) continue;
			if(!check(i)){
				flag=true;
				printf(&quot;T_T\n&quot;);
				break;
			} 
		}
		if(!flag) printf(&quot;^_^\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="后言t_t">后言T_T</h3>
<p>蒟蒻本想写“浅谈二分图最大匹配”来着，但是水平不够，就搁浅了。T_T</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2114 [NOI2014]起床困难综合症]]></title>
        <id>https://Kite-chaser.github.io/post/p2114-noi2014qi-chuang-kun-nan-zong-he-zheng</id>
        <link href="https://Kite-chaser.github.io/post/p2114-noi2014qi-chuang-kun-nan-zong-he-zheng">
        </link>
        <updated>2019-11-02T02:46:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。</p>
<p>由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在 0, 1, … , m中任选，但在通过防御门之后的攻击力不受m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2114">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>首先，我们肯定得先知道<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E6%88%96/10993689">或</a>、<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96">异或</a><br>
、<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E4%B8%8E/10993695">与</a>是什么意思。要不然就GG了。<br>
然后，这些都是位运算，也就是说，最后的结果只与x和操作有关，而结果的每一位只与x对应的位置上的值有关。位运算是二进制下的运算，所以状态十分简单，1或0。所以，我们可以从高位到低位，依次考虑x的每一位填0或填1。<br>
填1可行的情况：</p>
<ul>
<li>填了之后加上之前的不会大于m。</li>
<li>k位初值经过n个运算后，还等于初值。</li>
</ul>
<p>否则还是填0更优。确定每一位后，自然可以得到ans的值。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 100005
using namespace std;
int n,m,vl,ans;
pair&lt;string , int &gt; a[N];
char s[10];
int x;
int check(int bit,int now){
	for(int i=1;i&lt;=n;i++){
		x=a[i].second&gt;&gt;bit&amp;1;
		if(a[i].first==&quot;AND&quot;) now&amp;=x;
		else if(a[i].first==&quot;OR&quot;) now|=x;
		else now^=x;
	}
	return now;
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%s%d&quot;,s,&amp;x);
		a[i]=make_pair(s,x);
	}
	for(int bit=29;bit&gt;=0;bit--){
		int res0=check(bit,0);
		int res1=check(bit,1);
		if(vl+(1&lt;&lt;bit)&lt;=m&amp;&amp;res0&lt;res1) vl+=1&lt;&lt;bit,ans+=res1&lt;&lt;bit;
		else ans+=res0&lt;&lt;bit;
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>白嫖蓝书。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1072 Hankson 的趣味题]]></title>
        <id>https://Kite-chaser.github.io/post/p1072-hankson-de-qu-wei-ti</id>
        <link href="https://Kite-chaser.github.io/post/p1072-hankson-de-qu-wei-ti">
        </link>
        <updated>2019-10-31T12:38:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>Hanks 博士是 BT(Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。</p>
<p>今天在课堂上，老师讲解了如何求两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>设某未知正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>满足：</p>
<p>1.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最大公约数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>；<br>
2.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最小公倍数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>Hankson 的“逆问题”就是求出满足条件的正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>。但稍加思索之后，他发现这样的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的个数。请你帮助他编程求解这个问题。</p>
<h3 id="solve">Solve</h3>
<p>1、</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x,a_0)=a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">lcm(x,b_0)=b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
</blockquote>
<p>2、</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mo>&gt;</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mi mathvariant="normal">/</mi><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(x,a_0)=a_1=&gt;gcd(x/a_1,a_0/a_1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</blockquote>
<p>3、</p>
<blockquote>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">gcd(a,b)*lcm(a,b)=a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span><br>
所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>∗</mo><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x,b_0)*lcm(x,b_0)=x*b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">gcd(x,b_0)=x*b_0/lcm(x,b_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub><mi mathvariant="normal">/</mi><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x,b_0)=x*b_0/b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>b</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">gcd(x*b_1,b_0*b_1)=x*b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><msub><mi>b</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><msub><mi>b</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(b_1/b_0,b_1/x)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</blockquote>
<p>4、</p>
<blockquote>
<p>同时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1|x,x|b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>这样就使需要判断的条件简单了一些，解法也就出来了。<br>
枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的因数，然后判断是否符合结论。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
int n;
int a,b,c,d;
int ans;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int main()
{
	scanf(&quot;%d&quot;,&amp;n);
	while(n--){
		ans=0;
		scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
		for(int x=1;x*x&lt;=d;x++){
			int y=d/x;
			if(d%x!=0) continue;
			if(x%b==0&amp;&amp;gcd(x/b,a/b)==1&amp;&amp;gcd(d/c,d/x)==1) ans++;
			if(x==y) continue;
			if(y%b==0&amp;&amp;gcd(y/b,a/b)==1&amp;&amp;gcd(d/c,d/y)==1) ans++;
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[离散化]]></title>
        <id>https://Kite-chaser.github.io/post/chi-san-hua</id>
        <link href="https://Kite-chaser.github.io/post/chi-san-hua">
        </link>
        <updated>2019-10-31T10:56:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>离散化是程序设计中一个常用的技巧，它可以有效的降低时间复杂度。其基本思想就是在众多可能的情况中，只考虑需要用的值。离散化可以改进一个低效的算法，甚至实现根本不可能实现的算法。要掌握这个思想，必须从大量的题目中理解此方法的特点。例如，在建造线段树空间不够的情况下，可以考虑离散化。</p>
<h3 id="正文">正文</h3>
<p>离散化的使用在OI中使用十分广泛，主要用于数据的处理，那么他到底是个什么东西呢？</p>
<p>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小，将无穷大集合中的若干个元素映射为有限集合以便于统计。</p>
<p>假设问题涉及int范围内的n个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,这n个整数可能有重复，去重以后共有m个整数。我们要把每个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用一个1~m之间的整数代替，并且保持大小顺序不变，即如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>x小于（或等于、大于），那么代替<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的整数也小于（或等于、大于）代替<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的整数。</p>
<p>例如：</p>
<p>原数据：1,999,100000,15；处理后：1,3,4,2；</p>
<p>原数据：{100,200}，{20,50000}，{1,400}；</p>
<p>处理后：{3,4}，{2,6}，{1,5}；</p>
<p>离散化也是各种排序算法的一个应用。</p>
<p>离散化的思路也十分简单， 先排序，再删除重复元素，最后就是索引元素离散化后对应的值。</p>
<h4 id="code">Code</h4>
<pre><code class="language-cpp">void discrete(){// 或用STL中的unique
    sort(a+1,a+n+1);
    for(int i=1;i&lt;=n;i++){
        if(i==1||a[i]!=a[i-1]) b[++m]=a[i];
	}
}
int query(int x){//查询x映射为1~m之间那个整数
	return lower_bound(b+1,b+m+1,x)-b;
}
</code></pre>
<h3 id="关于lower_bound">关于lower_bound</h3>
<p>查找不小于x的元素中最小的一个，并返回指向该元素的迭代器（可以简单的理解为位置？）</p>
<h3 id="后言">后言</h3>
<p>生活中的“离散化”的例子还有很多，比如某一中的班级名单，按照学生的成绩排个序，然后从一号开始标，班级内的序号也就是班级内的排名。这也就避免了成绩的差距过大，比如我友链中那几个强者和我这样的菜鸡。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1955 [NOI2015]程序自动分析]]></title>
        <id>https://Kite-chaser.github.io/post/p1955-noi2015cheng-xu-zi-dong-fen-xi</id>
        <link href="https://Kite-chaser.github.io/post/p1955-noi2015cheng-xu-zi-dong-fen-xi">
        </link>
        <updated>2019-10-31T10:53:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p>
<p>考虑一个约束满足问题的简化版本：假设x1,x2,x3...代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p>
<p>现在给出一些约束满足问题，请分别对它们进行判定。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1955">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>简单点说，就是用并查集莽就完了。</p>
<p>用每个x做节点，然后，先检查等于的情况，将其中的x合并到一个集合中，最后检查不等于的情况，如果在一个集合内就是“NO”，如果都不在一个集合内就是“YES”。</p>
<p>但是有趣的是x的范围是10e9的，这要是做数组下标，那么一大堆MLE和CE都等着你，当场毙命。</p>
<p>于是我们理性的分析分析，虽然范围大，但是每次最多有2*n个数字不同，所以你懂我意思吧。</p>
<p><a href="https://kite-chaser.github.io/post/chi-san-hua">离散化</a>。</p>
<p>数据问题解决了，面前就是一马平川，莽！<strong>注意是多组数据，记得重置。</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define N 2100000
using namespace std;
int t,n;
int fa[N];
int num[N],cnt,len1,len2,op,b[N];
int x,y,z;
bool flag;
struct note{
	int u,v,w;
}d[N];
int find(int s){
	if(fa[s]!=s) fa[s]=find(fa[s]);
	return fa[s];
}
int query(int s){
	return lower_bound(b+1,b+op+1,s)-b;
}
int main()
{
	scanf(&quot;%d&quot;,&amp;t);
	while(t--){
		scanf(&quot;%d&quot;,&amp;n);
		cnt=0;op=0;len1=0;len2=n+1;flag=false;
		for(int i=1;i&lt;=2*n;i++) fa[i]=i;
		for(int i=1;i&lt;=n;i++){
			scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);
			num[++cnt]=x; 
			num[++cnt]=y;
			if(z) d[++len1].u=x,d[len1].v=y,d[len1].w=z;
			else d[--len2].u=x,d[len2].v=y,d[len2].w=z;
            //两个“指针”，两边放。
		}
		sort(num+1,num+1+cnt);
		for(int i=1;i&lt;=cnt;i++){
			if(i==1||num[i]!=num[i-1]) b[++op]=num[i];
		}
		for(int i=1;i&lt;=n;i++)d[i].u=query(d[i].u),d[i].v=query(d[i].v); 
		for(int i=1;i&lt;=n;i++){
			int e=find(d[i].u),r=find(d[i].v);
			if(d[i].w){
				if(e!=r) fa[r]=e;
			}
			else{
				if(e==r){flag=true;printf(&quot;NO\n&quot;);break;}
			}
		}
		if(!flag) printf(&quot;YES\n&quot;);
	}
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>小心用map，反正我的死了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[论GCD的玄学使用]]></title>
        <id>https://Kite-chaser.github.io/post/lun-gcd-de-xuan-xue-shi-yong</id>
        <link href="https://Kite-chaser.github.io/post/lun-gcd-de-xuan-xue-shi-yong">
        </link>
        <updated>2019-10-30T13:49:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>欧几里德算法又称辗转相除法是指用于计算两个正整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。</p>
<p>这是gcd的本职工作，代码也比较简单，证明就不再多解释。</p>
<h4 id="code">Code</h4>
<pre><code class="language-cpp">int gcd(int a,int b){
	return b?gcd(b,a%b):a;
}
</code></pre>
<h3 id="正文">正文</h3>
<p>接下来本文要讲的，才是gcd的<s>正确</s>打开方式。</p>
<p>OIer经常遇到这样的问题，就是如何判断在一个平面直角坐标系中或近似于平面直角坐标系中，判断两点之间有无其他整数点（横坐标和纵坐标都为整数的点），甚至让你求出具体个数。</p>
<p>比如这道例题。</p>
<h3 id="eg">EG</h3>
<h4 id="p1447-noi2010能量采集"><a href="https://www.luogu.org/problem/P1447">P1447 [NOI2010]能量采集</a></h4>
<h4 id="题目描述">题目描述</h4>
<p>栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。</p>
<p>栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。</p>
<p>由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。</p>
<p>能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能 量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。</p>
<p>下面给出了一个能量采集的例子，其中n = 5，m = 4，一共有20棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。</p>
<h4 id="solve">Solve</h4>
<p>一般来说，大多数写题解的人，会直接告诉你这个奇怪的结论。</p>
<p><strong>一个点（x,y）到原点之间的整数点个数即为gcd（x，y），包括（x,y)不包括原点，也就是k+1。</strong></p>
<p>之前我试了试之后发现这竟然是对的，但是不知道为什么是对的。翻遍有关的题解和资料都没有详细的解释。于是秉着<s>万丈高楼平地起，成功只能靠自己</s>认真的原则，就自己探求了一下，终于探求到其中的一点奥秘，与大家分享下。</p>
<p>其实也不是多么高深的东西。</p>
<p>首先，将一个整数点（x，y）看作一个直角三角形或是一个矩形，边长为x和y。称他为三角形或矩形（x，y）。</p>
<p>然后，设gcd（x，y）=d，那么三角形（x/d，y/d）也是直角边为整数的三角形。</p>
<p>那么，x和y分别乘上d分之一，d分之二……直到d分之d。这其中所有的三角形的直角边边长都是整数，对应到平面直角坐标系上就是d个点，这一点可以<s>性感</s>感性理解一下，或想想三角形的相似，就可以明白了。</p>
<p>所以，<strong>一个点（x,y）到原点之间的整数点个数即为gcd（x，y），包括（x,y)不包括原点，也就是k+1。</strong></p>
<p>这样再去分析类似的题目，就不会那么难搞了，<s>也能看懂题解了。</s></p>
]]></content>
    </entry>
</feed>