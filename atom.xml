<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Kite-chaser.github.io</id>
    <title>Kite-chaser</title>
    <updated>2019-10-29T12:23:48.352Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Kite-chaser.github.io"/>
    <link rel="self" href="https://Kite-chaser.github.io/atom.xml"/>
    <subtitle>This is my blog.</subtitle>
    <logo>https://Kite-chaser.github.io/images/avatar.png</logo>
    <icon>https://Kite-chaser.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Kite-chaser</rights>
    <entry>
        <title type="html"><![CDATA[P2845 [USACO15DEC]Switching on the Lights 开关灯]]></title>
        <id>https://Kite-chaser.github.io/post/p2845-usaco15decswitching-on-the-lights-kai-guan-deng</id>
        <link href="https://Kite-chaser.github.io/post/p2845-usaco15decswitching-on-the-lights-kai-guan-deng">
        </link>
        <updated>2019-10-29T11:45:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目背景">题目背景</h3>
<p>来源：usaco-2015-dec</p>
<p>Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个N*N的矩形网络。（1&lt;n&lt;100)</p>
<p>然而bessie十分怕黑，他想计算可以把多少个牛棚的灯打开。</p>
<h3 id="题目描述">题目描述</h3>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个房间，组成了一张<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的网格图，Bessie一开始位于左上角(1,1)，并且只能上下左右行走。</p>
<p>一开始，只有(1,1)这个房间的灯是亮着的，Bessie只能在亮着灯的房间里活动。</p>
<p>有另外M条信息，每条信息包含四个数a,b,c,d，表示房间(a,b)里有房间(c,d)的灯的开关。</p>
<p>请计算出最多有多少个房间的灯可以被打开</p>
<h3 id="说明提示">说明/提示</h3>
<p>这里，如果你看得懂英文的话，这里有样例的说明。</p>
<p>Here, Bessie can use the switch in (1,1)to turn on lights in (1,2)and (1,3). She can then walk to (1,3)and turn on the lights in (2,1)，from which she can turn on the lights in (2,2). The switch in (2,3)is inaccessible to her, being in an unlit room. She can therefore illuminate at most 5 rooms.</p>
<h3 id="手动机翻">手动机翻</h3>
<p>在这里，贝茜可以使用 （1，1） 中的开关打开 （1，2） 和 （1，3） 中的灯。然后，她可以步行到（1，3）并打开（2，1）中的灯，从中她可以打开灯（2，2）。她无法进入（2，3）的开关，她住在一间没有照明的房间里。因此，她最多能照亮5个房间。</p>
<blockquote>
<p><a href="https://www.luogu.org/record/25920729">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>BFS莽就完了。<br>
就是得注意不是找几个房间可以走到，而是可以开几个房间的灯。</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define N 1000
using namespace std;
int n,m,ans;
int x1,y1,x2,y2;
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
struct note{
	int x,y;
};
vector&lt;note&gt; g[N][N];
queue&lt;note&gt; q;
bool vis[N][N],fis[N][N];//vis是否房间开灯，fis是否被走到
void bfs(){
	q.push((note){1,1});vis[1][1]=true;fis[1][1]=true;ans=1;
	while(!q.empty()){
		note e=q.front();
		q.pop();
		int x=e.x,y=e.y;
		for(int i=0;i&lt;g[x][y].size();i++){
			int xx=g[x][y][i].x,yy=g[x][y][i].y;
			if(!vis[xx][yy]){
				vis[xx][yy]=true;
				ans++;
			}
			if((fis[xx-1][yy]||fis[xx][yy+1]||fis[xx+1][yy]||fis[xx][yy-1])&amp;&amp;!fis[xx][yy]) fis[xx][yy]=true,q.push((note){xx,yy});
		}
		for(int i=0;i&lt;4;i++){
			int xx=x+dx[i],yy=y+dy[i];
			if(!fis[xx][yy]&amp;&amp;vis[xx][yy]){
				fis[xx][yy]=true;
				q.push((note){xx,yy});
			}
		}
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
		g[x1][y1].push_back((note){x2,y2});
	}
	bfs();
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>附带一段神奇编译。</p>
<blockquote>
<p>/tmp/tmpv278mza7/src: 在函数‘void bfs()’中:<br>
/tmp/tmpv278mza7/src:24:16: 警告：comparison of integer expressions of different signedness: ‘int’ and ‘std::vector<note>::size_type’ {aka ‘long unsigned int’}    [-Wsign-compare]<br>
for(int i=0;i&lt;g[x][y].size();i++){<br>
<sub>^</sub>~~~~~~~~~~~~~</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4588 [TJOI2018]数学计算]]></title>
        <id>https://Kite-chaser.github.io/post/p4588-tjoi2018shu-xue-ji-suan</id>
        <link href="https://Kite-chaser.github.io/post/p4588-tjoi2018shu-xue-ji-suan">
        </link>
        <updated>2019-10-29T11:26:21.000Z</updated>
        <summary type="html"><![CDATA[<p>这真的是道线段树……</p>
]]></summary>
        <content type="html"><![CDATA[<p>这真的是道线段树……</p>
<!--more-->
<h3 id="题目描述">题目描述</h3>
<p>小豆现在有一个数x，初始值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.小豆有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>次操作，操作有两种类型:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>m</mi><mo>:</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1m:x=x\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>%mod;</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>p</mi><mi>o</mi><mi>s</mi><mo>:</mo><mi>x</mi><mo>=</mo><mi>x</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">2pos:x=x/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">/</span></span></span></span>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>次操作所乘的数（保证第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>次操作一定为类型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,对于每一个类型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的操作至多会被除一次）输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x%mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>;</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P4588">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>说实话，一开始我是真没看出来这是道线段树。<br>
以每一个时间节点作为叶子节点，，初始值都是1，区间求乘。</p>
<ul>
<li>1操作就是在相应的时间节点，修改为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。</li>
<li>2操作就是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>位置修改为1.</li>
</ul>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 100010
#define ll long long
using namespace std;
ll t;
ll Q,mod;
ll st[N],cnt;
struct note{
	ll l,r,num;
}d[N*4];
ll op,pos;
void build(ll k,ll x,ll y){
	d[k].l=x;d[k].r=y;d[k].num=1; 
	if(x==y) return ;
	build(k*2,x,(x+y)/2);
	build(k*2+1,(x+y)/2+1,y);
}
void revise(ll k,ll x,ll z){
	if(d[k].l==d[k].r){
		d[k].num=z%mod;
		return ;
	}
	ll mid=(d[k].l+d[k].r)/2;
	if(x&lt;=mid) revise(k*2,x,z);
	else revise(k*2+1,x,z);
	d[k].num=(d[k*2].num*d[k*2+1].num)%mod;
}
int main()
{
	scanf(&quot;%lld&quot;,&amp;t);
	while(t--){
		scanf(&quot;%lld%lld&quot;,&amp;Q,&amp;mod);
		build(1,1,Q);
		for(ll i=1;i&lt;=Q;i++){
			scanf(&quot;%lld%lld&quot;,&amp;op,&amp;pos);
			if(op==1) revise(1,i,pos);
			else revise(1,pos,1);
			printf(&quot;%lld\n&quot;,d[1].num);
		}
	}
	return 0;
}
</code></pre>
<h3 id="后言">后言</h3>
<p>话说有大佬说，这个题不用建树，直接莽就行。<s>可是不建树还是线段树吗？🙃</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[神奇的图]]></title>
        <id>https://Kite-chaser.github.io/post/shen-qi-de-tu</id>
        <link href="https://Kite-chaser.github.io/post/shen-qi-de-tu">
        </link>
        <updated>2019-10-29T11:22:01.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Kite-chaser.github.io/post-images/1572348146460.jpg" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UVA1753 Need for Speed]]></title>
        <id>https://Kite-chaser.github.io/post/uva1753-need-for-speed</id>
        <link href="https://Kite-chaser.github.io/post/uva1753-need-for-speed">
        </link>
        <updated>2019-10-28T12:11:38.000Z</updated>
        <summary type="html"><![CDATA[<p>OIer写代码，总会遇到几个玄学错误。</p>
]]></summary>
        <content type="html"><![CDATA[<p>OIer写代码，总会遇到几个玄学错误。</p>
<!--more-->
<h3 id="题意描述">题意描述</h3>
<p>Winniechen有一辆车， 但是它的迈速表指针坏掉的。当度数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>的时候， 车的实际速度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">s+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>是一个不确定的实数（常数。现在给你一段行程，包含n个路段， 保证每个路段是均速行驶的， 每个描述有两个数字， 分别为行驶的路程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和迈速表的读数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。整个行程一共用了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的时间， 请确定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>的值。另外请注意， 他的真实速度是永远保持在0以上的。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/UVA1753">原题链接</a></p>
</blockquote>
<h3 id="solve">Solve</h3>
<p>首先，我们蒙一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>做答案。<br>
<img src="https://Kite-chaser.github.io/post-images/1572265247371.png" alt=""><br>
然后试一试，如果用时超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的话，就是速度太慢了，应该给他提提速。如果小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的话，就是速度太快了，应该给他降一降，如果用时等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的话，bingo，恭喜你猜对了。<br>
所以，我们惊奇的发现，这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>具有“单调性”，这意味着什么？我们可以有规律地去猜。<br>
二分答案。而判断就是用用时与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>的关系。<br>
<strong>特殊之处就在于，是实数域上的二分。</strong><br>
无非就是把</p>
<pre><code class="language-cpp">while(l&lt;=r){
	mid=(l+r)&gt;&gt;1;
	if(···) l=mid+1;
	else r=mid-1; 
} 
</code></pre>
<p>换成</p>
<pre><code class="language-cpp">while(l&lt;=r-eps){
	mid=(l+r)/2;
	if(···) l=mid;
	else r=mid; 
} 
</code></pre>
<p>所有变量都是double类型。<strong>eps就是你想要卡的精度。</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 100000
#define db double
using namespace std;
int n;
db s[N],d[N];
db t,sum;
db l,r,mid,eps=1e-9;//就是这个
bool solve(db c){
	sum=0;
	for(int i=1;i&lt;=n;i++){
		if(s[i]+c&lt;=0) return true;//如果速度小于0的话就跟就GG了
		sum+=(d[i]/(s[i]+c)); 
	}
	if(sum&gt;t) return true;
	else return false;
}
int main()
{
	while(scanf(&quot;%d%lf&quot;,&amp;n,&amp;t)!=EOF){//记住这个“！=EOF”
		l=-20000000,r=20000000;
		for(int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;d[i],&amp;s[i]);
		for(int i=1;i&lt;=100;i++){
			mid=(l+r)/2;
			if(solve(mid)) l=mid;
			else r=mid;
		}
		printf(&quot;%.9lf\n&quot;,l);
	}
}
</code></pre>
<h3 id="后言">后言</h3>
<p>我原以为加不加EOF都一样的，或者是“~”取反，但是某谷给了我一个大大的耳光，我T飞了。<br>
所以观察答案有“单调性”的话，二分莽就完了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1948 [USACO08JAN]电话线Telephone Lines]]></title>
        <id>https://Kite-chaser.github.io/post/p1948-usaco08jandian-hua-xian-telephone-lines</id>
        <link href="https://Kite-chaser.github.io/post/p1948-usaco08jandian-hua-xian-telephone-lines">
        </link>
        <updated>2019-10-27T13:19:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system.</p>
<p>There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John's property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart.</p>
<p>The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used.</p>
<p>As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables.</p>
<p>Determine the minimum amount that Farmer John must pay.</p>
<p>多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着N(1&lt;=N&lt;=1000)根据1……n顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有p(1&lt;=p&lt;=10000)对电话杆可以拉电话线。其他的由于地震使得无法连接。</p>
<p>第i对电线杆的两个端点分别是ai,bi，它们的距离为li(1&lt;=li&lt;=1000000)。数据中每对(ai,bi)只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。</p>
<p>电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0.</p>
<p>请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1948">原题链接</a></p>
</blockquote>
<h2 id="solve">Solve</h2>
<p>一眼，这不就是分层图裸题吗？但是这个范围。<br>
虽然我没试过，但是这个范围会GG。于是我放弃了分层图。（其实有心的同学可以试一试。<br>
那么仔细分析一下这道题，发现求解的不是最小总代价，而是最小代价。而且这个代价是具有单调性的。<br>
也就是说，一个最小代价为x的可行情况，那么大于x的情况也可行。<br>
这就很明白了，二分答案。二分最小代价。<br>
那如何判断呢？想一想，拿当然是最短路惹。DJ，SPFA，乃至BFS都可以。<br>
我个人比较喜欢DJ。</p>
<p>众所周知<br>
<img src="https://Kite-chaser.github.io/post-images/1572183195997.png" alt=""><br>
其实这个题，SPFA也可以啦。<br>
解法也就出来了。<br>
二分答案+DJ/SPFA</p>
<ul>
<li>大于mid的边权设为1，小于等于mid的权值设为0。</li>
<li>跑最短路。</li>
<li>如果dis[n]&lt;=k的话就是可行的情况。</li>
</ul>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define N 100000
using namespace std;
int n,m,k;
int l=0,r=100000,mid,ans=-1;
int dis[N];
int u,v,w;
int head[N],len;
bool vis[N];
struct note{
	int to,vl,nxt;
}eg[N];
struct node{
	int u,vl;
	bool operator&lt;(const node &amp;a)const{
		return a.vl&lt;vl;
	}
};
priority_queue&lt;node&gt; q;
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].vl=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
bool dj(int s){
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;q.push((node){1,0});
	while(!q.empty()){
		int e=q.top().u;
		q.pop();
		vis[e]=false;
		for(int i=head[e];i;i=eg[i].nxt){
			int v=eg[i].to;
			int dist;
			if(eg[i].vl&gt;s) dist=1;
			else dist=0;
			if(dis[v]&gt;dis[e]+dist){
				dis[v]=dis[e]+dist;
				if(!vis[v]) vis[v]=true,q.push((node){v,dis[v]});
			}
		}
	}
	if(dis[n]&lt;=k) return true;
	else return false;
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);add(v,u,w);
		r=max(r,w);
	}
	while(l&lt;=r){
		int mid=(l+r)&gt;&gt;1;
		if(dj(mid)){
			r=mid-1;
			ans=mid;
		}
		else l=mid+1;
	}
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h2 id="后言">后言</h2>
<p>答案单调的二分莽就完了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分约束]]></title>
        <id>https://Kite-chaser.github.io/post/chai-fen-yue-shu</id>
        <link href="https://Kite-chaser.github.io/post/chai-fen-yue-shu">
        </link>
        <updated>2019-10-27T11:16:11.000Z</updated>
        <summary type="html"><![CDATA[<p>图论真的是博大精深。</p>
]]></summary>
        <content type="html"><![CDATA[<p>图论真的是博大精深。</p>
<!--more-->
<h2 id="前言">前言</h2>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。<br>
求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。</p>
<h2 id="正文">正文</h2>
<p>观察xj-xi&lt;=bk，会发现它类似最短路中的三角不等式d[v]&lt;=d[u]+w[u,v]，即d[v]-d[u]&lt;=w[u,v]。因此，以每个变量xi为结点，对于约束条件xj-xi&lt;=bk，连接一条边(i,j)，边权为bk。我们再增加一个源点s,s与所有定点相连，边权均为0。对这个图，以s为源点运行Bellman-ford算法（或SPFA算法），最终{d[ i]}即为一组可行解。<br>
例：d[x]-d[y]&gt;=Z<br>
如果想连边后求最长路 那么将不等式变形为这种形式 d[x]&gt;=d[y]+z y---x连一条权值为z的边<br>
求最短路则变形成d[y]&lt;=d[x]-z x---y连一条权值为-z的边。<br>
如果是别的不等式，也可以根据情况变形。<br>
为什么一定要用SPFA呢，因为这个系统可能无解。当最长路出现正环的时候或最短路出现负环的时候，这个系统就无解惹。其实，最长最短都差不多，视情况而定。</p>
<h2 id="eg">EG</h2>
<h3 id="p1993-小k的农场"><a href="https://www.luogu.org/problem/P1993">P1993 小K的农场</a></h3>
<h3 id="题目描述">题目描述</h3>
<p>小K在MC里面建立很多很多的农场，总共n个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共m个），以下列三种形式描述：</p>
<ul>
<li>农场a比农场b至少多种植了c个单位的作物，</li>
<li>农场a比农场b至多多种植了c个单位的作物，</li>
<li>农场a与农场b种植的作物数一样多。</li>
</ul>
<p>但是，由于小K的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。</p>
<h3 id="solve">Solve</h3>
<p>建图，求最长路。</p>
<ul>
<li>a-b&gt;=c,从b向a建一条边权为c的边。</li>
<li>a-b&lt;=c等于b-a&lt;=-c,从a向b建一条边权为-c的边。</li>
<li>a=b，等于a-b&gt;=0或b-a&gt;=0，双向建边，权值为0。<br>
每种情况分析完毕。<br>
超级源点为0。向每一个点建一条权值为0的边。<br>
SPFA跑最长路。<br>
<strong>一种玄学优化方式，用DFS优化SPFA，直接跑SPFA会T飞的。</strong></li>
</ul>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=23333333;
const int N=50005;
int n,m;
int num,x,y,z;
int first[N],nxt[N],to[N],dist[N],len;
int cnt[N],dis[N];
bool vis[N];
inline int read(){
    int k=0,f=1;
    char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){
        k=(k&lt;&lt;1)+(k&lt;&lt;3)+(ch^48);
        ch=getchar();
    }
    return k*f;
}
void add(int u,int v,int w){
	to[++len]=v;
	dist[len]=w;
	nxt[len]=first[u];
	first[u]=len;
}
bool spfa(int u){
	vis[u]=1;
	for(int i=first[u];i!=-1;i=nxt[i]){
		if(dis[to[i]]&lt;dis[u]+dist[i]){
			dis[to[i]]=dis[u]+dist[i];
			if(vis[to[i]]) return 0;
			if(!spfa(to[i])) return 0;
		}
	}
	vis[u]=0;
	return 1;
}
int main()
{
	memset(first,-1,sizeof(first));
	n=read();m=read();
	for(int i=1;i&lt;=m;i++){
		num=read();x=read();y=read();
		if(num==1) z=read(),add(y,x,z);
		else if(num==2) z=read(),add(x,y,-z);
		else if(num==3) add(x,y,0),add(y,x,0);
	}
	for(int i=1;i&lt;=n;i++) add(0,i,0),dis[i]=-maxn;;
	if(spfa(0)) printf(&quot;Yes&quot;);
	else printf(&quot;No&quot;);
	return 0;
} 
</code></pre>
<h2 id="后言">后言</h2>
<p>由此观之，许多看似后无头绪的题，其实可以用图论解决。就好像有指向性的状态可以用DAG建模。然后用相应的图论方法解决。所以OI题也要注意建模。</p>
<h2 id="相关例题">相关例题</h2>
<p><a href="https://www.luogu.org/problem/P2294">P2294 [HNOI2005]狡猾的商人</a><br>
<a href="https://www.luogu.org/problem/P3275">P3275 [SCOI2011]糖果</a><br>
<a href="https://www.luogu.org/problem/P3084">P3084 [USACO13OPEN]照片Photo</a><br>
<a href="https://www.luogu.org/problem/P4878">P4878 [USACO05DEC] 布局</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分层图]]></title>
        <id>https://Kite-chaser.github.io/post/fen-ceng-tu</id>
        <link href="https://Kite-chaser.github.io/post/fen-ceng-tu">
        </link>
        <updated>2019-10-27T02:17:58.000Z</updated>
        <summary type="html"><![CDATA[<p>黑科技。</p>
]]></summary>
        <content type="html"><![CDATA[<p>黑科技。</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>分层图就是一种上层可以到达下层，而下层不可以到达上层的图。<br>
其实重要的是一种构图方法。<br>
<img src="https://Kite-chaser.github.io/post-images/1572143056945.png" alt=""><br>
如图，黑色的边就是一层图，蓝色的边就是上层连向下层的图。</p>
<h2 id="eg1">EG1</h2>
<h3 id="p2939-usaco09feb改造路revamping-trails"><a href="https://www.luogu.org/problem/P2939">P2939 [USACO09FEB]改造路Revamping Trails</a></h3>
<h3 id="题目描述">题目描述</h3>
<p>Farmer John dutifully checks on the cows every day. He traverses some of the M (1 &lt;= M &lt;= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 &lt;= N &lt;= 10,000) pastures conveniently numbered 1..N on Farmer John's farm are currently connected by bidirectional dirt trails. Each trail i connects pastures P1_i and P2_i (1 &lt;= P1_i &lt;= N; 1 &lt;= P2_i &lt;= N) and requires T_i (1 &lt;= T_i &lt;= 1,000,000) units of time to traverse.</p>
<p>He wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 &lt;= K &lt;= 20) trails to turn into highways, which will effectively reduce the trail's traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N.</p>
<p>TIME LIMIT: 2 seconds</p>
<h3 id="题意翻译">题意翻译</h3>
<p>约翰一共有N)个牧场.由M条布满尘埃的小径连接.小径可 以双向通行.每天早上约翰从牧场1出发到牧场N去给奶牛检查身体.</p>
<p>通过每条小径都需要消耗一定的时间.约翰打算升级其中K条小径，使之成为高 速公路.在高速公路上的通行几乎是瞬间完成的，所以高速公路的通行时间为0.</p>
<p>请帮助约翰决定对哪些小径进行升级，使他每天从1号牧场到第N号牧场所花的时间最短</p>
<h3 id="solve">Solve</h3>
<p>枚举每个边设零，然后跑最短路？k=1可能还可以，但是k&lt;=20，直接毙命。<br>
分层图于是闪亮登场。其实这道题还可以用动态规划做，但是在这里我们只讨论分层图（<s>其实是蒟蒻不会啦</s>）<br>
升级k条路径，就分k+1层图。第一层就是原图，每一层图内的点和边权都跟原图一样。但是层与层之间的边的边权为零。上层的u点连向下层的v点，边权为零，就相当于升级了这条小径，经过k层跑最短路到达n点，就相当于经过了已经升级了k条边的最短路。<br>
不一定要升级k条边，所以取每层图的最小代价。</p>
<h4 id="建图">建图</h4>
<pre><code class="language-cpp">for(int i=1;i&lt;=m;i++){
	scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
	add(u,v,w);add(v,u,w);
	for(int j=1;j&lt;=k;j++){
		add(u+j*n,v+j*n,w);
		add(v+j*n,u+j*n,w);
		add(u+(j-1)*n,v+j*n,0);
		add(v+(j-1)*n,u+j*n,0);//当然无向图需要双向
	}
}
</code></pre>
<p><strong>tip:分层图重要的是构造图的方法,最短路的话，随便啦。但是还是说一句“SPFA死了”</strong></p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define N 10000000
using namespace std;
int n,m,k,ans;
int u,v,w;
int dis[N];
int head[N],len;
struct note{
	int to,vl,nxt;
}eg[N];
struct node{
	int u,vl;
	bool operator&lt;(const node &amp;a)const{
		return a.vl&lt;vl;
	}
};
priority_queue&lt;node&gt; q;
bool vis[N];
void add(int u,int v,int w){
	len++;
	eg[len].to=v;
	eg[len].vl=w;
	eg[len].nxt=head[u];
	head[u]=len;
}
void dj(){
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	q.push((node){1,0});
	while(!q.empty()){
		int e=q.top().u;
		q.pop();
		if(vis[e]) continue;
		vis[e]=true;
		for(int i=head[e];i;i=eg[i].nxt){
			int v=eg[i].to;
			if(dis[v]&gt;dis[e]+eg[i].vl){
				dis[v]=dis[e]+eg[i].vl;
				if(!vis[v]) q.push((node){v,dis[v]});
			}
		}
	}
}
int main()
{
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);add(v,u,w);
		for(int j=1;j&lt;=k;j++){
			add(u+j*n,v+j*n,w);
			add(v+j*n,u+j*n,w);
			add(u+(j-1)*n,v+j*n,0);
			add(v+(j-1)*n,u+j*n,0);
		}
	}
	dj();
	ans=dis[n];
	for(int i=1;i&lt;=k;i++) ans=min(ans,dis[n+i*n]);
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
<h2 id="后言">后言</h2>
<p>这个方法真的很适合图中优化几次边权然后求最小代价的题。话说这个题的数组范围是我二分出来的，一个个试出来的20000000太大，5000000太小。GG。</p>
<h2 id="画外音">画外音</h2>
<p>数据过大的话，分层图可能就GG了。而这个时候就该用其他的方法惹。</p>
<h2 id="相关题目">相关题目</h2>
<p><a href="https://www.luogu.org/problem/P4822">P4822 [BJWC2012]冻结</a><br>
<a href="https://www.luogu.org/problem/P4568">P4568 [JLOI2011]飞行路线</a></p>
<h2 id="关于">关于</h2>
<p>[例图取自]（https://www.luogu.org/blog/xiaohou/fen-ceng-tu）<br>
封面不是啦。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3870 [TJOI2009]开关]]></title>
        <id>https://Kite-chaser.github.io/post/p3870-tjoi2009kai-guan</id>
        <link href="https://Kite-chaser.github.io/post/p3870-tjoi2009kai-guan">
        </link>
        <updated>2019-10-07T08:08:35.000Z</updated>
        <summary type="html"><![CDATA[<p>分块是一种优雅的暴力。</p>
]]></summary>
        <content type="html"><![CDATA[<p>分块是一种优雅的暴力。</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>现有N（2 ≤ N ≤ 100000）盏灯排成一排，从左到右依次编号为：1，2，......，N。然后依次执行M（1 ≤ M ≤ 100000）项操作，操作分为两种：第一种操作指定一个区间[a, b]，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开），第二种操作是指定一个区间[a, b]，要求你输出这个区间内有多少盏灯是打开的。灯在初始时都是关着的。</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P3870">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<ol>
<li>将n盏灯的状态分块。1表示开着，0表示关着。</li>
<li>tg[]表示每个块的修改状态。</li>
<li>通过“^”操作快速修改。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#define N 100001
using namespace std;
int n,m;
int t;
int ans;
int cnt,x,y;
struct note{
	int l,r,sum;
}d[N];
int num[N],tg[N];
int ln[N];
void ch(int l,int r){
	if(ln[l]==ln[r]){
		for(int i=l;i&lt;=r;i++){
			d[ln[i]].sum-=(num[i]^tg[ln[i]]);
			num[i]=1-num[i];
			d[ln[i]].sum+=(num[i]^tg[ln[i]]);
		}
	}
	else{
		for(int i=l;i&lt;=d[ln[l]].r;i++){
			d[ln[i]].sum-=(num[i]^tg[ln[i]]);
			num[i]=1-num[i];
			d[ln[i]].sum+=(num[i]^tg[ln[i]]);
		}
		for(int i=d[ln[r]].l;i&lt;=r;i++){
			d[ln[i]].sum-=(num[i]^tg[ln[i]]);
			num[i]=1-num[i];
			d[ln[i]].sum+=(num[i]^tg[ln[i]]);
		}
		for(int i=ln[l]+1;i&lt;=ln[r]-1;i++){
			tg[i]=1-tg[i];
			d[i].sum=(d[i].r-d[i].l+1)-d[i].sum;
		}
	}
}
int qu(int l,int r){
	if(ln[l]==ln[r]){
		for(int i=l;i&lt;=r;i++) ans+=(num[i]^tg[ln[i]]);
		return ans;
	}
	else{
		for(int i=l;i&lt;=d[ln[l]].r;i++) ans+=(num[i]^tg[ln[l]]);
		for(int i=d[ln[r]].l;i&lt;=r;i++) ans+=(num[i]^tg[ln[r]]);
		for(int i=ln[l]+1;i&lt;=ln[r]-1;i++){
			ans+=d[i].sum;
		}
		return ans;
	}
}
int main()
{
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	t=sqrt(n);
	for(int i=1;i&lt;=t;i++){
		d[i].l=(i-1)*t+1;
		d[i].r=i*t;
	}
	if(d[t].r&lt;n){
		t++;
		d[t].l=d[t-1].r+1;
		d[t].r=n;
	}
	int s=1;
	for(int i=1;i&lt;=n;i++){
		if(d[s].r&lt;i) s++;
		ln[i]=s;
	}
	for(int i=1;i&lt;=m;i++){
		scanf(&quot;%d%d%d&quot;,&amp;cnt,&amp;x,&amp;y);
		if(cnt){
			ans=0;
			printf(&quot;%d\n&quot;,qu(x,y));
		}
		else ch(x,y);
	}
	return 0; 
}
</code></pre>
<h2 id="关于分块">关于分块</h2>
<p>没有学过分块的朋友可以康康hzw大神的<a href="http://hzwer.com/8053.html">分块九讲</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2986 [USACO10MAR]伟大的奶牛聚集Great Cow Gat…]]></title>
        <id>https://Kite-chaser.github.io/post/p2986-usaco10marwei-da-de-nai-niu-ju-ji-great-cow-gat</id>
        <link href="https://Kite-chaser.github.io/post/p2986-usaco10marwei-da-de-nai-niu-ju-ji-great-cow-gat">
        </link>
        <updated>2019-10-03T10:08:28.000Z</updated>
        <summary type="html"><![CDATA[<p>话说描述下面一大坨是什么东西……</p>
]]></summary>
        <content type="html"><![CDATA[<p>话说描述下面一大坨是什么东西……</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>Bessie is planning the annual Great Cow Gathering for cows all across the country and, of course, she would like to choose the most convenient location for the gathering to take place.</p>
<p>Bessie正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。</p>
<p>Each cow lives in one of N (1 &lt;= N &lt;= 100,000) different barns (conveniently numbered 1..N) which are connected by N-1 roads in such a way that it is possible to get from any barn to any other barn via the roads. Road i connects barns A_i and B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N) and has length L_i (1 &lt;= L_i &lt;= 1,000). The Great Cow Gathering can be held at any one of these N barns. Moreover, barn i has C_i (0 &lt;= C_i &lt;= 1,000) cows living in it.</p>
<p>每个奶牛居住在 N(1&lt;=N&lt;=100,000) 个农场中的一个，这些农场由N-1条道路连接，并且从任意一个农场都能够到达另外一个农场。道路i连接农场A_i和B_i(1 &lt;= A_i &lt;=N; 1 &lt;= B_i &lt;= N),长度为L_i(1 &lt;= L_i &lt;= 1,000)。集会可以在N个农场中的任意一个举行。另外，每个牛棚中居住者C_i(0 &lt;= C_i &lt;= 1,000)只奶牛。</p>
<p>When choosing the barn in which to hold the Cow Gathering, Bessie wishes to maximize the convenience (which is to say minimize the inconvenience) of the chosen location. The inconvenience of choosing barn X for the gathering is the sum of the distances all of the cows need to travel to reach barn X (i.e., if the distance from barn i to barn X is 20, then the travel distance is C_i*20). Help Bessie choose the most convenient location for the Great Cow Gathering.</p>
<p>在选择集会的地点的时候，Bessie希望最大化方便的程度(也就是最小化不方便程度)。比如选择第X个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和，(比如，农场i到达农场X的距离是20，那么总路程就是C_i*20)。帮助Bessie找出最方便的地点来举行大集会。</p>
<p>Consider a country with five barns with [various capacities] connected by various roads of varying lengths. In this set of barns, neither barn 3 nor barn 4 houses any cows.</p>
<p>1 3 4 5</p>
<p>@--1--@--3--@--3--@[2]</p>
<p>[1] |</p>
<p>2 | @[1] 2 Bessie can hold the Gathering in any of five barns; here is the table of inconveniences calculated for each possible location:</p>
<p>Gather ----- Inconvenience ------</p>
<p>Location B1 B2 B3 B4 B5 Total</p>
<p>1 0 3 0 0 14 17</p>
<p>2 3 0 0 0 16 19</p>
<p>3 1 2 0 0 12 15</p>
<p>4 4 5 0 0 6 15</p>
<p>5 7 8 0 0 0 15</p>
<p>If Bessie holds the gathering in barn 1, then the inconveniences from each barn are:</p>
<p>Barn 1 0 -- no travel time there!</p>
<p>Barn 2 3 -- total travel distance is 2+1=3 x 1 cow = 3 Barn 3 0 -- no cows there!</p>
<p>Barn 4 0 -- no cows there!</p>
<p>Barn 5 14 -- total travel distance is 3+3+1=7 x 2 cows = 14 So the total inconvenience is 17.</p>
<p>The best possible convenience is 15, achievable at by holding the Gathering at barns 3, 4, or 5.</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P2986">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<p>简单点说就是用树的重心求解。<br>
类似于这种树上到一点然后求最小价值的题大多是树的重心。<br>
也就是所求的这一点。<br>
有关树的重心，见蒟蒻的<a href="https://kite-chaser.github.io/post/shu-de-chong-xin/">笔记</a>。<br>
然后从树的重心，求到各点的路径长度和代价即可。</p>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
#define N 100001
using namespace std;
ll n;
ll maxn=1000000000000000000,ans;
ll cnt,sum;
ll c[N];
ll x,y,z;
ll dis[N],d[N];  //dis-从树的重心到节点的路径长度
ll first[N*2],nxt[N*2],to[N*2],w[N*2],len;
void add(ll u,ll v,ll z){
	to[++len]=v;
	w[len]=z;
	nxt[len]=first[u];
	first[u]=len;
}
void dp(ll s,ll fa){
	d[s]=c[s];
	ll res=0;
	for(ll i=first[s];i!=-1;i=nxt[i]){
		if(to[i]==fa) continue;
		dp(to[i],s);
		d[s]+=d[to[i]];
		res=max(res,d[to[i]]);
	}
	res=max(res,sum-d[s]);
	if(res&lt;maxn){
		maxn=res;
		cnt=s;
	}
}
void dfs(ll s,ll fa){
	for(ll i=first[s];i!=-1;i=nxt[i]){
		if(to[i]==fa) continue;
		dis[to[i]]=dis[s]+w[i];
		dfs(to[i],s);
	}
}
int main()
{
	memset(first,-1,sizeof(first));
	scanf(&quot;%lld&quot;,&amp;n);
	for(ll i=1;i&lt;=n;i++){
		scanf(&quot;%lld&quot;,&amp;c[i]);sum+=c[i];
	}
	for(ll i=1;i&lt;n;i++){
		scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;z);
		add(x,y,z);
		add(y,x,z);
	}
	dp(1,1);
	dis[cnt]=0;
	dfs(cnt,cnt);
	for(ll i=1;i&lt;=n;i++){
		ans+=dis[i]*c[i];
	}
	printf(&quot;%lld&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1270 “访问”美术馆]]></title>
        <id>https://Kite-chaser.github.io/post/p1270-fang-wen-mei-zhu-guan</id>
        <link href="https://Kite-chaser.github.io/post/p1270-fang-wen-mei-zhu-guan">
        </link>
        <updated>2019-09-21T09:45:36.000Z</updated>
        <summary type="html"><![CDATA[<p>我肝了好久……</p>
]]></summary>
        <content type="html"><![CDATA[<p>我肝了好久……</p>
<!--more-->
<h2 id="题目描述">题目描述</h2>
<p>经过数月的精心准备，Peer Brelstet，一个出了名的盗画者，准备开始他的下一个行动。艺术馆的结构，每条走廊要么分叉为两条走廊，要么通向一个展览室。Peer知道每个展室里藏画的数量，并且他精确测量了通过每条走廊的时间。由于经验老到，他拿下一幅画需要5秒的时间。你的任务是编一个程序，计算在警察赶来之前，他最多能偷到多少幅画。<br>
<img src="https://Kite-chaser.github.io/post-images/1569059240907.png" alt=""><br>
样例的图……</p>
<blockquote>
<p><a href="https://www.luogu.org/problem/P1270">原题链接</a></p>
</blockquote>
<h2 id="slove">Slove</h2>
<p>树形DP-树形背包<br>
mon[i]到节点i的用时<br>
<s>十年DP推方程</s></p>
<ol>
<li>设计状态：d[i][j]，以i为根节点，取画j副时的最少用时。</li>
<li>边界：d[i][j]=j*5,(i为展室，0&lt;=j&lt;=该展室画数）</li>
<li>转移方程：d[u][j]=min(d[u][j],d[u][j-k]+d[v][k]+mon[v]).（u到v有边；j为u的最大画数）</li>
<li>按照最大画幅，倒序枚举，用时低于S的就是答案。</li>
</ol>
<h2 id="code">Code</h2>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 1010
using namespace std;
int s;
int tree[N*10];
int mon[N],vl[N],cnt;
int d[N][N];
int sz[N],sum;
int first[N],nxt[N],to[N],len;
void add(int u,int v){
	to[++len]=v;
	nxt[len]=first[u];
	first[u]=len;
}
void infs(int u){
	mon[u]=mon[u]*2;
	if(vl[u]){
		sum+=vl[u];
		for(int i=0;i&lt;=vl[u];i++) d[u][i]=i*5;
		return ;
	}
	scanf(&quot;%d%d&quot;,&amp;mon[u*2],&amp;vl[u*2]);
	add(u,u*2);infs(u*2);
	scanf(&quot;%d%d&quot;,&amp;mon[u*2+1],&amp;vl[u*2+1]);
	add(u,u*2+1),infs(u*2+1);
}
void dfs(int u){
	if(vl[u]){
		sz[u]=vl[u];
		return ;
	}
	for(int i=first[u];i!=-1;i=nxt[i]){
		dfs(to[i]);
		sz[u]+=sz[to[i]];
		for(int j=sz[u];j&gt;=0;j--){
			for(int k=min(j,sz[to[i]]);k&gt;=0;k--) d[u][j]=min(d[u][j],d[u][j-k]+d[to[i]][k]+mon[to[i]]);
		}
	}
}
int main()
{
	memset(first,-1,sizeof(first));
	for(int i=0;i&lt;=1001;i++) for(int j=1;j&lt;=1001;j++) d[i][j]=30000;
	scanf(&quot;%d&quot;,&amp;s);
	s--;
	add(0,1);
	scanf(&quot;%d%d&quot;,&amp;mon[1],&amp;vl[1]);
	infs(1);
	dfs(0);
	for(int i=sum;i&gt;=0;i--){
		if(d[0][i]&lt;s){
			printf(&quot;%d&quot;,i);
			return 0;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>